<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Smart Parking Search - Intelligent Parking Solutions</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: #667eea;
    }

    .user-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .user-greeting {
      font-weight: 500;
    }

    .logout-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: #ff5252;
      transform: translateY(-1px);
    }

    .main-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 2rem;
    }

    .main-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Tab Navigation Styles */
    .tab-navigation {
      display: flex;
      background: rgba(102, 126, 234, 0.05);
      border-bottom: 2px solid rgba(102, 126, 234, 0.1);
    }

    .tab-button {
      flex: 1;
      padding: 1.5rem 2rem;
      background: none;
      border: none;
      color: #666;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .tab-button:hover {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
    }

    .tab-button.active {
      background: white;
      color: #667eea;
      border-bottom: 3px solid #667eea;
    }

    .tab-button.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(135deg, #667eea, #764ba2);
    }

    /* Tab Content Styles */
    .tab-content {
      display: none;
      padding: 2rem;
      animation: fadeIn 0.3s ease-in-out;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .tab-placeholder {
      text-align: center;
      padding: 4rem 2rem;
      color: #666;
    }

    .tab-placeholder h3 {
      color: #667eea;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .tab-placeholder p {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .coming-soon {
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: bold;
      font-size: 1.2rem;
      margin-top: 1rem;
    }

    /* Modern Search Section Styles */
    .search-section {
      margin-bottom: 3rem;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.03), rgba(118, 75, 162, 0.03));
      border-radius: 20px;
      padding: 2rem;
      border: 1px solid rgba(102, 126, 234, 0.08);
    }

    .search-section h4 {
      color: #667eea;
      font-size: 1.3rem;
      margin-bottom: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .search-input-group {
      display: grid;
      grid-template-columns: 2fr 1fr auto;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    input[type="text"], select {
      padding: 1.2rem 1.5rem;
      border: 2px solid rgba(102, 126, 234, 0.1);
      border-radius: 16px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      font-weight: 500;
    }

    input[type="text"] {
      position: relative;
    }

    input[type="text"]::placeholder {
      color: #94a3b8;
      font-weight: 400;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      background: white;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.08), 0 4px 20px rgba(102, 126, 234, 0.12);
      transform: translateY(-1px);
    }

    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 1rem center;
      background-repeat: no-repeat;
      background-size: 1rem;
      padding-right: 3rem;
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 1.2rem 2rem;
      border-radius: 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: fit-content;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4);
      background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
    }

    button:hover:not(:disabled)::before {
      left: 100%;
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .parking-filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 16px;
      border: 1px solid rgba(102, 126, 234, 0.05);
    }

    .parking-filters label {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .parking-filters select {
      margin-top: 0.5rem;
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      border-radius: 12px;
    }

    .map-container {
      width: 100%;
      height: 400px;
      border-radius: 12px;
      overflow: hidden;
      margin: 1rem 0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .parking-filters {
      display: grid;
      gap: 1rem;
      flex-wrap: wrap;
      margin: 1rem 0;
    }

    .parking-filters label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
    }

    .info, .error, .success {
      padding: 1rem;
      border-radius: 12px;
      margin: 1rem 0;
      font-weight: 500;
    }

    .info {
      background: rgba(33, 150, 243, 0.1);
      color: #1976d2;
      border-left: 4px solid #2196f3;
    }

    .error {
      background: rgba(244, 67, 54, 0.1);
      color: #d32f2f;
      border-left: 4px solid #f44336;
    }

    .success {
      background: rgba(76, 175, 80, 0.1);
      color: #388e3c;
      border-left: 4px solid #4caf50;
    }

    .results-section {
      margin-top: 2rem;
    }

    .parking-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 1rem;
    }

    .parking-spot {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
      backdrop-filter: blur(10px);
      padding: 1.8rem;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border: 2px solid rgba(102, 126, 234, 0.08);
      position: relative;
      overflow: hidden;
    }

    .parking-spot::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .parking-spot:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.12);
      border-color: rgba(102, 126, 234, 0.2);
    }

    .parking-spot:hover::before {
      opacity: 1;
    }

    .parking-spot h5 {
      color: #1a202c;
      margin-bottom: 1.2rem;
      font-size: 1.2rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
      animation: pulse 2s infinite;
    }

    .status-free {
      background: #10b981;
    }

    .status-occupied {
      background: #ef4444;
    }

    .status-reserved {
      background: #f59e0b;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .parking-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.8rem;
      font-size: 0.9rem;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .parking-info:last-of-type {
      border-bottom: none;
      margin-bottom: 1rem;
    }

    .parking-info span:first-child {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .parking-info span:last-child {
      font-weight: 700;
      color: #1a202c;
      background: rgba(102, 126, 234, 0.1);
      padding: 0.25rem 0.75rem;
      border-radius: 8px;
      font-size: 0.9rem;
    }

    .eco-badge, .ev-badge {
      display: inline-block;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 0.4rem 0.8rem;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 600;
      margin: 0.25rem 0.25rem 0.25rem 0;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .ev-badge {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .parking-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .navigate-btn {
      flex: 1;
      background: linear-gradient(135deg, #10b981, #059669);
      font-size: 0.9rem;
      font-weight: 600;
      padding: 1rem 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border-radius: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .navigate-btn:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
    }

    @media (max-width: 768px) {
      .header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
      }

      .main-container {
        padding: 0 1rem;
      }

      .tab-button {
        padding: 1rem;
        font-size: 0.9rem;
      }

      .tab-content {
        padding: 1rem;
      }

      .search-input-group {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .search-section {
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .parking-filters {
        grid-template-columns: 1fr;
        gap: 1rem;
        padding: 1rem;
      }

      .parking-results-grid {
        grid-template-columns: 1fr;
      }

      input[type="text"], select, button {
        padding: 1rem 1.2rem;
        font-size: 0.95rem;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="logo">üÖøÔ∏è Smart Parking Search</div>
    <div class="user-section">
      <div id="userGreeting" class="user-greeting">Loading...</div>
      <button id="logoutBtn" class="logout-btn" style="display: none;">Logout</button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Main Content -->
    <div class="main-content">
      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button class="tab-button active" data-tab="parking">
          üÖøÔ∏è Find Parking Spots
        </button>
        <button class="tab-button" data-tab="statistics">
          üìä Statistics
        </button>
        <button class="tab-button" data-tab="eco">
          üå± Eco Planning
        </button>
      </div>

      <!-- Tab Content: Find Parking Spots -->
      <div class="tab-content active" id="parking-tab">
        <h3>üÖøÔ∏è Find Parking Spots</h3>
        
        <!-- Search Section -->
        <div class="search-section">
          <h4>Search for Parking</h4>
          <div class="search-input-group">
            <input type="text" id="parkingLocationInput" placeholder="Enter location or address" />
            <select id="parkingTypeSelect">
              <option value="all">All Types</option>
              <option value="street">Street Parking</option>
              <option value="garage">Parking Garage</option>
              <option value="lot">Parking Lot</option>
              <option value="private">Private Parking</option>
            </select>
            <button id="searchParkingBtn">Search Parking</button>
          </div>
          
          <div class="parking-filters">
            <label>Max Distance: 
              <select id="maxDistanceSelect">
                <option value="0.5">0.5 km</option>
                <option value="1">1 km</option>
                <option value="2" selected>2 km</option>
                <option value="5">5 km</option>
                <option value="10">10 km</option>
                <option value="20">20 km (All Melbourne)</option>
              </select>
            </label>
            
            <label>Price Range: 
              <select id="priceRangeSelect">
                <option value="all">Any Price</option>
                <option value="free">Free</option>
                <option value="low">$0-$5/hour</option>
                <option value="medium">$5-$15/hour</option>
                <option value="high">$15+/hour</option>
              </select>
            </label>

            <label>Availability: 
              <select id="availabilitySelect">
                <option value="all">All Spots</option>
                <option value="available">üü¢ Available Only</option>
                <option value="occupied">üî¥ Occupied Only</option>
                <option value="reserved">üü° Reserved Only</option>
              </select>
            </label>
          </div>
          
          <div id="parkingSearchStatus" class="info">Ready to search for parking spots across all Melbourne areas</div>
          
          <!-- Google Map for Parking Search -->
          <div id="parkingMap" class="map-container"></div>
        </div>

        <!-- Parking Results Section -->
        <div id="parkingResultsSection" class="results-section" style="display: none;">
          <h4>Available Parking Spots</h4>
          <div id="parkingResultsCount" class="results-count"></div>
          <div id="parkingResultsGrid" class="parking-results-grid"></div>
        </div>
      </div>

      <!-- Tab Content: Statistics -->
      <div class="tab-content" id="statistics-tab">
        <div class="tab-placeholder">
          <h3>üìä Parking Statistics</h3>
          <p>Analytics and insights about parking usage</p>
          <p>Track your parking history and patterns</p>
          <div class="coming-soon">Coming Soon</div>
        </div>
      </div>

      <!-- Tab Content: Eco Planning -->
      <div class="tab-content" id="eco-tab">
        <div class="tab-placeholder">
          <h3>üå± Eco-Friendly Planning</h3>
          <p>Sustainable parking and transportation options</p>
          <p>Carbon footprint tracking and green routes</p>
          <div class="coming-soon">Coming Soon</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Google Maps API -->
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwXzBClakuchQF0zxKk0UBkPhLX--d7tg&libraries=places&callback=initMaps"></script>

  <script>
    // Tab functionality
    function initTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');
          
          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(`${targetTab}-tab`).classList.add('active');
        });
      });
    }

    // Google Maps Configuration
    let parkingMap;
    let placesService;
    let parkingAutocomplete;
    let parkingMarkers = [];

    // Melbourne coordinates - broader area to show all suburbs
    const MELBOURNE_CENTER = { lat: -37.8136, lng: 144.9631 };
    const MELBOURNE_BOUNDS = {
      north: -37.4,   // Northern suburbs
      south: -38.2,   // Southern suburbs  
      east: 145.5,    // Eastern suburbs
      west: 144.4     // Western suburbs
    };

    // Global variables
    let userTokens = null;
    let isAuthenticated = false;
    let melbourneParkingData = [];

    // DOM elements
    const userGreeting = document.getElementById('userGreeting');
    const logoutBtn = document.getElementById('logoutBtn');
    const parkingLocationInput = document.getElementById('parkingLocationInput');
    const searchParkingBtn = document.getElementById('searchParkingBtn');
    const parkingSearchStatus = document.getElementById('parkingSearchStatus');
    const parkingResultsSection = document.getElementById('parkingResultsSection');
    const parkingResultsGrid = document.getElementById('parkingResultsGrid');

    // Debug mode
    const DEBUG_MODE = true;

    function debugLog(message, data = null) {
      if (DEBUG_MODE) {
        console.log(`[Smart Parking Search DEBUG] ${message}`, data);
      }
    }

    // Initialize Google Maps
    async function initMaps() {
      debugLog('Initializing Google Maps');
      
      // Load parking data first
      await loadParkingData();
      
      // Initialize parking search map - zoom out to show all Melbourne
      parkingMap = new google.maps.Map(document.getElementById('parkingMap'), {
        zoom: 10,  // Zoomed out to show entire Melbourne area
        center: MELBOURNE_CENTER,
        styles: [
          {
            featureType: 'poi',
            elementType: 'labels',
            stylers: [{ visibility: 'off' }]
          }
        ]
      });

      // Initialize places service
      placesService = new google.maps.places.PlacesService(parkingMap);

      // Setup autocomplete for parking search - expanded bounds for all Melbourne
      parkingAutocomplete = new google.maps.places.Autocomplete(
        parkingLocationInput,
        {
          bounds: new google.maps.LatLngBounds(
            new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
            new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
          ),
          strictBounds: false  // Allow searches outside bounds but prioritize Melbourne
        }
      );

      parkingAutocomplete.addListener('place_changed', onParkingLocationSelected);

      debugLog('Google Maps initialized successfully');
      
      // Initialize authentication after maps are ready
      initAuth();
      
      // Load real parking data for Melbourne CBD by default
      setTimeout(() => {
        if (melbourneParkingData.length > 0) {
          loadRealParkingData();
        } else {
          // If data isn't loaded yet, try again
          setTimeout(() => {
            loadRealParkingData();
          }, 2000);
        }
      }, 1000);
      
      // Also set the input to show Melbourne as default (broader area)
      parkingLocationInput.value = "Melbourne, VIC, Australia";
    }

    // Load parking data from S3 or local CSV file
    async function loadParkingData() {
      debugLog('Starting parking data load process...');
      
      // S3 URL for the CSV file
      const S3_CSV_URL = 'https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bays.csv';
      // You can also use other cloud storage services:
      // const S3_CSV_URL = 'https://your-bucket.s3.ap-southeast-2.amazonaws.com/parking-data.csv';
      
      // Try S3 first, then local file, then fallback to sample data
      
      // Method 1: Try loading from S3
      try {
        debugLog('Attempting to load CSV from S3:', S3_CSV_URL);
        const response = await fetch(S3_CSV_URL, {
          method: 'GET',
          mode: 'cors', // Enable CORS
          headers: {
            'Accept': 'text/csv,text/plain,*/*'
          }
        });
        
        debugLog(`S3 Response status: ${response.status} ${response.statusText}`);
        debugLog(`S3 Response headers:`, Object.fromEntries(response.headers.entries()));
        
        if (response.ok) {
          const csvContent = await response.text();
          debugLog(`S3 Response content length: ${csvContent ? csvContent.length : 0} characters`);
          
          if (csvContent && csvContent.length > 100) {
            debugLog(`SUCCESS: CSV loaded from S3! Content length: ${csvContent.length} characters`);
            debugLog('First 200 characters:', csvContent.substring(0, 200));
            await parseCSVContent(csvContent);
            return;
          } else {
            debugLog('S3 response content is empty or too small');
          }
        } else {
          debugLog(`S3 fetch failed with status: ${response.status} - ${response.statusText}`);
          
          // Try to read the error response
          try {
            const errorText = await response.text();
            debugLog('S3 error response:', errorText);
          } catch (e) {
            debugLog('Could not read S3 error response');
          }
        }
      } catch (error) {
        debugLog('S3 loading error details:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        
        // Check for specific error types
        if (error.name === 'TypeError' && error.message.includes('CORS')) {
          debugLog('CORS ERROR: S3 bucket needs CORS configuration');
        } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
          debugLog('FETCH ERROR: Network or URL issue');
        }
      }
      
      // Method 2: Try loading from local file system (for development)
      try {
        if (window.fs && window.fs.readFile) {
          debugLog('Attempting to read local CSV file...');
          const csvContent = await window.fs.readFile('on-street-parking-bays.csv', { encoding: 'utf8' });
          
          if (csvContent && csvContent.length > 100) {
            debugLog(`SUCCESS: CSV loaded locally! Content length: ${csvContent.length} characters`);
            await parseCSVContent(csvContent);
            return;
          }
        }
      } catch (error) {
        debugLog('Local CSV file loading failed:', error.message);
      }
      
      // Method 3: Fallback to sample data with instructions
      debugLog('All loading methods failed, using sample data');
      showS3Instructions();
    }

    // Parse CSV content into parking data
    async function parseCSVContent(csvContent) {
      debugLog('Parsing CSV content...');
      
      try {
        const lines = csvContent.trim().split('\n');
        if (lines.length < 2) {
          debugLog('ERROR: CSV has insufficient lines:', lines.length);
          showS3Instructions();
          return;
        }

        // Parse headers
        const headerLine = lines[0];
        const headers = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < headerLine.length; i++) {
          const char = headerLine[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            headers.push(current.trim().replace(/"/g, ''));
            current = '';
          } else {
            current += char;
          }
        }
        headers.push(current.trim().replace(/"/g, ''));
        
        debugLog('CSV Headers found:', headers);

        // Verify we have the expected columns
        const requiredColumns = ['Latitude', 'Longitude', 'RoadSegmentDescription'];
        const missingColumns = requiredColumns.filter(col => !headers.includes(col));
        if (missingColumns.length > 0) {
          debugLog('ERROR: Missing required columns:', missingColumns);
          showS3Instructions();
          return;
        }

        melbourneParkingData = [];
        let processedRows = 0;
        let validRows = 0;
        
        // Process each data row with progress logging for large datasets
        const totalLines = lines.length - 1;
        
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          processedRows++;
          
          // Log progress for large datasets
          if (processedRows % 5000 === 0) {
            debugLog(`Processing progress: ${processedRows}/${totalLines} rows (${Math.round(processedRows/totalLines*100)}%)`);
          }
          
          // Parse CSV line handling quoted values
          const values = [];
          let currentValue = '';
          let inQuotes = false;
          
          for (let j = 0; j < line.length; j++) {
            const char = line[j];
            if (char === '"') {
              inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
              values.push(currentValue.trim().replace(/^"|"$/g, ''));
              currentValue = '';
            } else {
              currentValue += char;
            }
          }
          values.push(currentValue.trim().replace(/^"|"$/g, ''));
          
          // Create parking spot object
          const spot = {};
          headers.forEach((header, index) => {
            let value = values[index] || '';
            
            if (header === 'RoadSegmentID' && value) {
              spot[header] = parseInt(value);
            } else if (header === 'KerbsideID' && value) {
              spot[header] = value ? parseInt(value) : null;
            } else if ((header === 'Latitude' || header === 'Longitude') && value) {
              spot[header] = parseFloat(value);
            } else {
              spot[header] = value;
            }
          });
          
          // Validate the row has required data
          if (spot.Latitude && spot.Longitude && spot.RoadSegmentDescription && 
              !isNaN(spot.Latitude) && !isNaN(spot.Longitude) &&
              spot.Latitude >= -39 && spot.Latitude <= -37 &&
              spot.Longitude >= 144 && spot.Longitude <= 146) {
            melbourneParkingData.push(spot);
            validRows++;
          }
        }
        
        debugLog(`SUCCESS: Processed ${processedRows} rows, found ${validRows} valid parking spots from real Melbourne data`);
        
        // Sample some locations to verify data coverage
        const sampleSpots = melbourneParkingData.slice(0, 5);
        debugLog('Sample parking locations loaded:');
        sampleSpots.forEach((spot, idx) => {
          debugLog(`  ${idx + 1}. ${spot.RoadSegmentDescription}`);
        });
        
        // Show success message
        setTimeout(() => {
          parkingSearchStatus.innerHTML = `
            <strong>‚úÖ Real Data Loaded!</strong><br>
            Successfully loaded ${validRows} parking spots from your CSV data via S3
          `;
          parkingSearchStatus.className = 'success';
        }, 500);
        
      } catch (error) {
        debugLog('Error parsing CSV content:', error);
        showS3Instructions();
      }
    }

    // Show error message if real data cannot be loaded
    function showS3Instructions() {
      debugLog('‚ö†Ô∏è  Real CSV data could not be loaded from S3 or local file');
      
      // Clear any existing data
      melbourneParkingData = [];
      
      debugLog('No sample data created - app will only work with real CSV data');
      
      // Show detailed error message with troubleshooting steps
      setTimeout(() => {
        parkingSearchStatus.innerHTML = `
          <strong>‚ùå Unable to Load Real Parking Data from S3</strong><br><br>
          
          <strong>Current S3 URL:</strong><br>
          <code>https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bays.csv</code><br><br>
          
          <strong>Common Issues & Solutions:</strong><br>
          1. <strong>CORS Policy:</strong> S3 bucket needs CORS configuration to allow web access<br>
          2. <strong>Public Access:</strong> Ensure the CSV file has public read permissions<br>
          3. <strong>File Location:</strong> Verify the file was uploaded to the correct path<br>
          4. <strong>File Format:</strong> Ensure it's a valid CSV file<br><br>
          
          <strong>S3 CORS Configuration Needed:</strong><br>
          <code>
          {<br>
          &nbsp;&nbsp;"AllowedOrigins": ["*"],<br>
          &nbsp;&nbsp;"AllowedMethods": ["GET"],<br>
          &nbsp;&nbsp;"AllowedHeaders": ["*"]<br>
          }
          </code><br><br>
          
          <strong>Check browser console (F12) for detailed error messages.</strong><br>
          <small>App requires real data - no sample data available.</small>
        `;
        parkingSearchStatus.className = 'error';
        
        // Hide results section since no data is available
        parkingResultsSection.style.display = 'none';
      }, 1000);
    }

    // Handle parking location selection
    function onParkingLocationSelected() {
      const place = parkingAutocomplete.getPlace();
      if (!place.geometry) {
        debugLog('No geometry found for selected place');
        return;
      }

      debugLog('Location selected:', place.name);
      parkingMap.setCenter(place.geometry.location);
      parkingMap.setZoom(16);
      
      // Clear previous status and show searching
      parkingSearchStatus.innerText = 'üîç Searching for parking near selected location...';
      parkingSearchStatus.className = 'info';
      
      // Search for nearby parking automatically
      searchNearbyParking(place.geometry.location);
    }

    // Authentication functions
    async function initAuth() {
      debugLog('Initializing authentication');
      
      // For demo purposes, simulate authentication
      isAuthenticated = true;
      userTokens = { accessToken: 'demo-token', idToken: 'demo-id-token' };
      
      const userInfo = { username: 'Demo User', email: 'demo@example.com' };
      
      userGreeting.innerHTML = `Welcome, <strong>${userInfo.username}</strong>`;
      logoutBtn.style.display = 'inline-block';
      
      debugLog('Demo authentication successful');
    }

    function logout() {
      location.reload();
    }

    logoutBtn.addEventListener('click', logout);

    // Event listeners
    searchParkingBtn.addEventListener('click', searchParking);

    parkingLocationInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchParking();
      }
    });

    document.getElementById('maxDistanceSelect').addEventListener('change', function() {
      const location = parkingLocationInput.value.trim();
      if (location) {
        debugLog('Distance filter changed, re-searching...');
        searchParking();
      }
    });

    document.getElementById('parkingTypeSelect').addEventListener('change', function() {
      if (parkingResultsSection.style.display !== 'none') {
        debugLog('Parking type filter changed, re-filtering results...');
        const location = parkingLocationInput.value.trim();
        if (location) {
          searchParking();
        }
      }
    });

    document.getElementById('availabilitySelect').addEventListener('change', function() {
      if (parkingResultsSection.style.display !== 'none') {
        debugLog('Availability filter changed, re-filtering results...');
        const location = parkingLocationInput.value.trim();
        if (location) {
          searchParking();
        }
      }
    });

    function searchParking() {
      const location = parkingLocationInput.value.trim();
      
      if (!location) {
        parkingSearchStatus.innerText = '‚ùå Please enter a location.';
        parkingSearchStatus.className = 'error';
        return;
      }

      parkingSearchStatus.innerText = 'üîç Searching for parking spots...';
      parkingSearchStatus.className = 'info';
      searchParkingBtn.disabled = true;

      // Geocode the location first
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ address: location }, (results, status) => {
        if (status === 'OK') {
          const searchLocation = results[0].geometry.location;
          parkingMap.setCenter(searchLocation);
          parkingMap.setZoom(16);
          
          searchNearbyParking(searchLocation);
        } else {
          parkingSearchStatus.innerText = '‚ùå Location not found.';
          parkingSearchStatus.className = 'error';
          searchParkingBtn.disabled = false;
        }
      });
    }

    // Find nearby parking spots from CSV data
    function findNearbyParkingSpots(centerLat, centerLng, radiusKm = 1) {
      if (!melbourneParkingData || melbourneParkingData.length === 0) {
        debugLog('No parking data available');
        return [];
      }

      const spots = melbourneParkingData.filter(spot => {
        if (!spot.Latitude || !spot.Longitude) return false;
        
        // Calculate distance using Haversine formula for better accuracy
        const R = 6371; // Earth's radius in kilometers
        const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
        const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c; // Distance in km
        
        return distance <= radiusKm;
      });
      
      // Sort by distance and return top results
      return spots.map(spot => {
        const R = 6371;
        const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
        const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c * 1000; // Distance in meters
        
        return {
          ...spot,
          distance: Math.round(distance)
        };
      }).sort((a, b) => a.distance - b.distance);
    }

    function searchNearbyParking(location) {
      debugLog('Searching for parking near location:', location.toString());
      
      // Clear existing markers and results
      parkingMarkers.forEach(marker => marker.setMap(null));
      parkingMarkers = [];
      parkingResultsSection.style.display = 'none';

      const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);
      
      // Update status
      parkingSearchStatus.innerText = 'üîç Finding parking spots nearby...';
      parkingSearchStatus.className = 'info';

      // Use CSV data to find nearby parking spots
      const nearbySpots = findNearbyParkingSpots(location.lat(), location.lng(), maxDistance);
      
      if (nearbySpots && nearbySpots.length > 0) {
        // Add random status to each spot for filtering
        const spotsWithStatus = nearbySpots.map(spot => ({
          ...spot,
          status: ['free', 'occupied', 'reserved'][Math.floor(Math.random() * 3)]
        }));

        // Filter based on parking type if needed
        const parkingType = document.getElementById('parkingTypeSelect').value;
        let filteredSpots = spotsWithStatus;
        
        if (parkingType !== 'all') {
          filteredSpots = spotsWithStatus.filter(spot => {
            const desc = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';
            switch (parkingType) {
              case 'street':
                return desc.includes('street') || desc.includes('road') || desc.includes('avenue');
              case 'garage':
                return desc.includes('garage') || desc.includes('building') || desc.includes('car park');
              case 'lot':
                return desc.includes('lot') || desc.includes('park') && !desc.includes('national');
              case 'private':
                return desc.includes('private') || desc.includes('secure');
              default:
                return true;
            }
          });
        }

        // Filter based on availability
        const availabilityFilter = document.getElementById('availabilitySelect').value;
        if (availabilityFilter !== 'all') {
          const statusMap = {
            'available': 'free',
            'occupied': 'occupied', 
            'reserved': 'reserved'
          };
          filteredSpots = filteredSpots.filter(spot => spot.status === statusMap[availabilityFilter]);
        }
        
        // Limit to top 20 results for better performance
        const topResults = filteredSpots.slice(0, 20);
        
        displayCSVParkingResults(topResults, location);
        
        // Also add markers for broader area (with same availability filter applied)
        let markerResults = filteredSpots.slice(0, 100);
        addAllParkingMarkers(markerResults);
        
        const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
        parkingSearchStatus.innerText = `‚úÖ Found ${topResults.length}${availabilityText} parking spots nearby (${markerResults.length} shown on map)`;
        parkingSearchStatus.className = 'success';
        parkingResultsSection.style.display = 'block';
      } else {
        const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
        parkingSearchStatus.innerText = `‚ùå No${availabilityText} parking spots found in this area. Try adjusting your filters.`;
        parkingSearchStatus.className = 'error';
      }
      
      // Re-enable search button
      searchParkingBtn.disabled = false;
    }

    function displayCSVParkingResults(spots, searchLocation) {
      // Update results count
      const availabilityFilter = document.getElementById('availabilitySelect').value;
      const filterText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
      document.getElementById('parkingResultsCount').innerText = 
        `Found ${spots.length}${filterText} real parking spots from Melbourne data`;

      // Create parking spot cards
      let resultsHTML = '';
      spots.forEach((spot, index) => {
        // Extract street name for cleaner display
        const streetName = spot.RoadSegmentDescription ? 
          spot.RoadSegmentDescription.split(' between')[0] : 'Parking Spot';
        
        // Determine if updated recently (within last year)
        const lastUpdated = new Date(spot.LastUpdated);
        const isRecent = lastUpdated > new Date('2023-01-01');
        
        // Use the status from the spot (added during search)
        const randomStatus = spot.status || 'free';
        
        // Status display text and styling
        const statusConfig = {
          free: { text: 'Available', class: 'status-free', emoji: 'üü¢' },
          occupied: { text: 'Occupied', class: 'status-occupied', emoji: 'üî¥' },
          reserved: { text: 'Reserved', class: 'status-reserved', emoji: 'üü°' }
        };
        
        const status = statusConfig[randomStatus];
        
        resultsHTML += `
          <div class="parking-spot">
            <h5>
              üÖøÔ∏è ${streetName}
              <span class="status-indicator ${status.class}"></span>
            </h5>
            <div class="parking-info">
              <span>Status</span>
              <span style="background: ${randomStatus === 'free' ? 'rgba(16, 185, 129, 0.1); color: #059669' : randomStatus === 'occupied' ? 'rgba(239, 68, 68, 0.1); color: #dc2626' : 'rgba(245, 158, 11, 0.1); color: #d97706'}">${status.emoji} ${status.text}</span>
            </div>
            <div class="parking-info">
              <span>Location</span>
              <span>${spot.RoadSegmentDescription.length > 30 ? spot.RoadSegmentDescription.substring(0, 30) + '...' : spot.RoadSegmentDescription}</span>
            </div>
            <div class="parking-info">
              <span>Distance</span>
              <span>üìç ${spot.distance}m away</span>
            </div>
            <div class="parking-info">
              <span>Segment ID</span>
              <span>#${spot.RoadSegmentID}</span>
            </div>
            <div class="parking-info">
              <span>Last Updated</span>
              <span>üïí ${spot.LastUpdated}</span>
            </div>
            ${isRecent ? '<div class="eco-badge">‚úÖ Recently Updated</div>' : ''}
            ${spot.KerbsideID ? '<div class="ev-badge">üè∑Ô∏è Tracked Spot</div>' : ''}
            <div class="parking-actions">
              <button class="navigate-btn" onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${streetName.replace(/'/g, "\\'")}')">
                üß≠ Navigate
              </button>
            </div>
          </div>
        `;
      });

      parkingResultsGrid.innerHTML = resultsHTML;
    }

    // Load real parking data for Melbourne (ALL areas) - ONLY real data, no samples
    function loadRealParkingData() {
      debugLog('loadRealParkingData called');
      parkingSearchStatus.innerText = 'üîç Loading Melbourne parking spots from real data...';
      parkingSearchStatus.className = 'info';
      
      // Clear existing markers
      parkingMarkers.forEach(marker => marker.setMap(null));
      parkingMarkers = [];

      // Check if we have real parking data loaded
      if (!melbourneParkingData || melbourneParkingData.length === 0) {
        debugLog('ERROR: No real parking data available');
        parkingSearchStatus.innerText = '‚ùå No real parking data loaded. Check S3 configuration.';
        parkingSearchStatus.className = 'error';
        parkingResultsSection.style.display = 'none';
        return;
      }

      debugLog(`Processing ${melbourneParkingData.length} real parking data points from entire Melbourne`);

      // Analyze the geographic distribution of real parking data
      const allSpots = melbourneParkingData.map(spot => {
        const distance = Math.round(
          Math.sqrt(
            Math.pow((spot.Latitude - MELBOURNE_CENTER.lat) * 111000, 2) + 
            Math.pow((spot.Longitude - MELBOURNE_CENTER.lng) * 111000, 2)
          )
        );
        return { ...spot, distance };
      });

      // Group spots by distance to see real distribution
      const spotsByDistance = {
        cbd: allSpots.filter(s => s.distance <= 2000),      // Within 2km of center
        inner: allSpots.filter(s => s.distance > 2000 && s.distance <= 10000),  // 2-10km
        outer: allSpots.filter(s => s.distance > 10000)     // Beyond 10km
      };

      debugLog(`Real parking distribution: CBD (${spotsByDistance.cbd.length}), Inner (${spotsByDistance.inner.length}), Outer (${spotsByDistance.outer.length})`);

      // Sample spots from different areas for display (but all from real data)
      const displaySpots = [];
      
      // Add CBD spots
      displaySpots.push(...spotsByDistance.cbd.slice(0, 40));
      
      // Add inner Melbourne spots  
      displaySpots.push(...spotsByDistance.inner.slice(0, 40));
      
      // Add outer Melbourne spots
      displaySpots.push(...spotsByDistance.outer.slice(0, 20));

      // Sort by distance for results display
      const sortedSpots = displaySpots.sort((a, b) => a.distance - b.distance);
      
      debugLog(`Selected ${sortedSpots.length} real parking spots for display across different Melbourne areas`);
      
      if (sortedSpots && sortedSpots.length > 0) {
        displayCSVParkingResults(sortedSpots, { lat: () => MELBOURNE_CENTER.lat, lng: () => MELBOURNE_CENTER.lng });
        parkingSearchStatus.innerText = `‚úÖ Loaded ${allSpots.length} REAL Melbourne parking spots (${spotsByDistance.cbd.length} CBD, ${spotsByDistance.inner.length} inner, ${spotsByDistance.outer.length} outer suburbs)`;
        parkingSearchStatus.className = 'success';
        parkingResultsSection.style.display = 'block';
        
        // Add real parking spots as markers, sampled for performance
        const allMarkerSpots = [];
        // Sample every 10th spot from CBD
        for (let i = 0; i < spotsByDistance.cbd.length; i += 10) {
          allMarkerSpots.push(spotsByDistance.cbd[i]);
        }
        // Sample every 20th spot from inner
        for (let i = 0; i < spotsByDistance.inner.length; i += 20) {
          allMarkerSpots.push(spotsByDistance.inner[i]);
        }
        // Sample every 50th spot from outer
        for (let i = 0; i < spotsByDistance.outer.length; i += 50) {
          allMarkerSpots.push(spotsByDistance.outer[i]);
        }
        
        addAllParkingMarkers(allMarkerSpots);
        debugLog(`Added ${allMarkerSpots.length} markers from real data across all Melbourne areas`);
        
        // Log some sample real locations to verify coverage
        debugLog('Sample REAL outer suburb locations:');
        spotsByDistance.outer.slice(0, 5).forEach(spot => {
          debugLog(`  ${spot.RoadSegmentDescription} - Distance: ${spot.distance}m`);
        });
        
      } else {
        debugLog('No real parking spots available for display');
        parkingSearchStatus.innerText = '‚ùå No real parking data available for display.';
        parkingSearchStatus.className = 'error';
        parkingResultsSection.style.display = 'none';
      }
    }

    // Add function to display many markers on map
    function addAllParkingMarkers(spots) {
      spots.forEach((spot, index) => {
        // Generate random status for demo (in real app, this would come from API)
        const statusOptions = ['free', 'occupied', 'reserved'];
        const randomStatus = statusOptions[Math.floor(Math.random() * statusOptions.length)];
        
        // Marker colors based on status
        const markerColors = {
          free: '#10b981',      // Green
          occupied: '#ef4444',   // Red
          reserved: '#f59e0b'    // Amber/Orange
        };
        
        const markerColor = markerColors[randomStatus];
        
        const marker = new google.maps.Marker({
          position: { lat: spot.Latitude, lng: spot.Longitude },
          map: parkingMap,
          title: `${spot.RoadSegmentDescription} (${spot.distance}m away)`,
          icon: {
            url: 'data:image/svg+xml;base64,' + btoa(`
              <svg width="24" height="24" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" fill="${markerColor}" stroke="#ffffff" stroke-width="2"/>
                <circle cx="12" cy="12" r="6" fill="${markerColor}" opacity="0.8"/>
                <text x="12" y="16" text-anchor="middle" fill="white" font-size="10" font-family="Arial" font-weight="bold">P</text>
              </svg>
            `),
            scaledSize: new google.maps.Size(24, 24),
            anchor: new google.maps.Point(12, 12)
          }
        });

        // Status display configuration
        const statusConfig = {
          free: { text: 'Available', emoji: 'üü¢', color: '#10b981' },
          occupied: { text: 'Occupied', emoji: 'üî¥', color: '#ef4444' },
          reserved: { text: 'Reserved', emoji: 'üü°', color: '#f59e0b' }
        };
        
        const status = statusConfig[randomStatus];

        // Enhanced info window with status
        const infoWindow = new google.maps.InfoWindow({
          content: `
            <div style="padding: 12px; max-width: 280px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                <h5 style="margin: 0; color: #1a202c; font-size: 1.1rem; font-weight: 700;">üÖøÔ∏è ${spot.RoadSegmentDescription.length > 35 ? spot.RoadSegmentDescription.substring(0, 35) + '...' : spot.RoadSegmentDescription}</h5>
              </div>
              
              <div style="background: ${status.color}15; border-left: 4px solid ${status.color}; padding: 8px 12px; border-radius: 8px; margin-bottom: 12px;">
                <div style="display: flex; align-items: center; gap: 6px;">
                  <span style="font-size: 14px;">${status.emoji}</span>
                  <strong style="color: ${status.color}; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">${status.text}</strong>
                </div>
              </div>
              
              <div style="display: grid; gap: 6px; font-size: 0.85rem;">
                <div style="display: flex; justify-content: space-between;">
                  <span style="color: #6b7280; font-weight: 600;">Distance:</span>
                  <span style="font-weight: 700; color: #1a202c;">üìç ${spot.distance}m</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                  <span style="color: #6b7280; font-weight: 600;">Segment ID:</span>
                  <span style="font-weight: 700; color: #1a202c;">#${spot.RoadSegmentID}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                  <span style="color: #6b7280; font-weight: 600;">Updated:</span>
                  <span style="font-weight: 700; color: #1a202c;">üïí ${spot.LastUpdated}</span>
                </div>
              </div>
            </div>
          `
        });

        marker.addListener('click', () => {
          // Close other info windows
          parkingMarkers.forEach(m => {
            if (m.infoWindow) {
              m.infoWindow.close();
            }
          });
          infoWindow.open(parkingMap, marker);
        });

        marker.infoWindow = infoWindow;
        parkingMarkers.push(marker);
      });

      debugLog(`Added ${spots.length} parking markers to map with status colors`);
    }

    // Navigation function to open Google Maps with directions
    function navigateToParking(lat, lng, name) {
      debugLog('Opening navigation to parking spot', { lat, lng, name });
      
      // Create Google Maps URL for navigation
      const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_name=${encodeURIComponent(name)}`;
      
      // Open in new tab/window
      window.open(googleMapsUrl, '_blank');
    }

    // Error handling for Google Maps API
    window.gm_authFailure = function() {
      debugLog('Google Maps API authentication failed');
      document.getElementById('parkingMap').innerHTML = 
        '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666;"><p>‚ö†Ô∏è Google Maps API key required. Please add your API key to enable maps.</p></div>';
    };

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', function() {
      debugLog('Smart Parking Search app initialized');
      
      // Initialize tabs
      initTabs();
      
      // If Google Maps fails to load, show fallback
      setTimeout(() => {
        if (typeof google === 'undefined') {
          debugLog('Google Maps API not loaded, showing fallback');
          document.getElementById('parkingMap').innerHTML = 
            '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; flex-direction: column;"><p>üó∫Ô∏è Parking Map</p><p style="font-size: 0.9rem; margin-top: 0.5rem;">Add your Google Maps API key to enable full functionality</p></div>';
          
          // Still initialize auth for demo
          initAuth();
        }
      }, 3000);
    });
  </script>
</body>
</html>