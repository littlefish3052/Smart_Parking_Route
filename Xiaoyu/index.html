
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Plotly for statistics charts -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Smart Parking Search - Intelligent Parking Solutions</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: #667eea;
    }

    .user-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .user-greeting {
      font-weight: 500;
    }

    .logout-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: #ff5252;
      transform: translateY(-1px);
    }

    .main-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 2rem;
    }

    .main-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Tab Navigation Styles */
    .tab-navigation {
      display: flex;
      background: rgba(102, 126, 234, 0.05);
      border-bottom: 2px solid rgba(102, 126, 234, 0.1);
    }

    .tab-button {
      flex: 1;
      padding: 1.5rem 2rem;
      background: none;
      border: none;
      color: #666;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .tab-button:hover {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
    }

    .tab-button.active {
      background: white;
      color: #667eea;
      border-bottom: 3px solid #667eea;
    }

    .tab-button.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(135deg, #667eea, #764ba2);
    }

    /* Tab Content Styles */
    .tab-content {
      display: none;
      padding: 2rem;
      animation: fadeIn 0.3s ease-in-out;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .tab-placeholder {
      text-align: center;
      padding: 4rem 2rem;
      color: #666;
    }

    .tab-placeholder h3 {
      color: #667eea;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .tab-placeholder p {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .coming-soon {
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: bold;
      font-size: 1.2rem;
      margin-top: 1rem;
    }

    /* Modern Search Section Styles */
    .search-section {
      margin-bottom: 3rem;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.03), rgba(118, 75, 162, 0.03));
      border-radius: 20px;
      padding: 2rem;
      border: 1px solid rgba(102, 126, 234, 0.08);
    }

    .search-section h4 {
      color: #667eea;
      font-size: 1.3rem;
      margin-bottom: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .search-input-group {
      display: grid;
      grid-template-columns: 2fr 1fr auto;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    input[type="text"], select {
      padding: 1.2rem 1.5rem;
      border: 2px solid rgba(102, 126, 234, 0.1);
      border-radius: 16px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      font-weight: 500;
    }

    input[type="text"] {
      position: relative;
    }

    input[type="text"]::placeholder {
      color: #94a3b8;
      font-weight: 400;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      background: white;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.08), 0 4px 20px rgba(102, 126, 234, 0.12);
      transform: translateY(-1px);
    }

    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 1rem center;
      background-repeat: no-repeat;
      background-size: 1rem;
      padding-right: 3rem;
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 1.2rem 2rem;
      border-radius: 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: fit-content;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4);
      background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
    }

    button:hover:not(:disabled)::before {
      left: 100%;
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .parking-filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 16px;
      border: 1px solid rgba(102, 126, 234, 0.05);
    }

    .parking-filters label {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .parking-filters select {
      margin-top: 0.5rem;
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      border-radius: 12px;
    }

    .map-container {
      width: 100%;
      height: 400px;
      border-radius: 12px;
      overflow: hidden;
      margin: 1rem 0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .info, .error, .success {
      padding: 1rem;
      border-radius: 12px;
      margin: 1rem 0;
      font-weight: 500;
    }

    .info {
      background: rgba(33, 150, 243, 0.1);
      color: #1976d2;
      border-left: 4px solid #2196f3;
    }

    .error {
      background: rgba(244, 67, 54, 0.1);
      color: #d32f2f;
      border-left: 4px solid #f44336;
    }

    .success {
      background: rgba(76, 175, 80, 0.1);
      color: #388e3c;
      border-left: 4px solid #4caf50;
    }

    .results-section {
      margin-top: 2rem;
    }

    .results-count {
      font-size: 0.9rem;
      color: #6b7280;
      margin-bottom: 1rem;
      padding: 0.5rem 1rem;
      background: rgba(102, 126, 234, 0.05);
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    .parking-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 1rem;
    }

    .parking-spot {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
      backdrop-filter: blur(10px);
      padding: 1.8rem;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border: 2px solid rgba(102, 126, 234, 0.08);
      position: relative;
      overflow: hidden;
    }

    .parking-spot::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .parking-spot:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.12);
      border-color: rgba(102, 126, 234, 0.2);
    }

    .parking-spot:hover::before {
      opacity: 1;
    }

    .parking-spot h5 {
      color: #1a202c;
      margin-bottom: 1.2rem;
      font-size: 1.2rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
      animation: pulse 2s infinite;
    }

    .status-free {
      background: #10b981;
    }

    .status-occupied {
      background: #ef4444;
    }

    .status-reserved {
      background: #f59e0b;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .parking-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.8rem;
      font-size: 0.9rem;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .parking-info:last-of-type {
      border-bottom: none;
      margin-bottom: 1rem;
    }

    .parking-info span:first-child {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .parking-info span:last-child {
      font-weight: 700;
      color: #1a202c;
      background: rgba(102, 126, 234, 0.1);
      padding: 0.25rem 0.75rem;
      border-radius: 8px;
      font-size: 0.9rem;
    }

    .eco-badge, .ev-badge {
      display: inline-block;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 0.4rem 0.8rem;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 600;
      margin: 0.25rem 0.25rem 0.25rem 0;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .ev-badge {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .parking-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .navigate-btn {
      flex: 1;
      background: linear-gradient(135deg, #10b981, #059669);
      font-size: 0.9rem;
      font-weight: 600;
      padding: 1rem 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border-radius: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .navigate-btn:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
    }

    .current-choice {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(102, 126, 234, 0.02));
      border: 2px solid #667eea !important;
      position: relative;
    }

    .current-choice::after {
      content: '✓ Your Choice';
      position: absolute;
      top: -8px;
      right: 12px;
      background: #667eea;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    @media (max-width: 768px) {
      .header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
      }

      .main-container {
        padding: 0 1rem;
      }

      .tab-button {
        padding: 1rem;
        font-size: 0.9rem;
      }

      .tab-content {
        padding: 1rem;
      }

      .search-input-group {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .search-section {
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .parking-filters {
        grid-template-columns: 1fr;
        gap: 1rem;
        padding: 1rem;
      }

      .parking-results-grid {
        grid-template-columns: 1fr;
      }

      input[type="text"], select, button {
        padding: 1rem 1.2rem;
        font-size: 0.95rem;
      }

      /* notes & insights */
      .muted-note{color:#6b7280;font-size:.85rem;margin-top:.35rem}
      .insight-box{
        background:rgba(102,126,234,.06);
        border:1px solid rgba(102,126,234,.15);
        color:#374151;
        border-radius:12px;
        padding:12px 14px;
        margin:10px 0 16px 0;
        line-height:1.55;
      }
      .insight-box em{font-style:normal;color:#667eea;font-weight:600}
      }
      
      /* Statistics charts grid */
      .stats-charts-grid{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
      }

      /* 手机端：改为单列，并给图更高的可视高度 */
      @media (max-width: 768px){
        .stats-charts-grid{ grid-template-columns: 1fr !important; }
        #stats-chart1, #stats-chart2{ height: 420px !important; }
      }



  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="logo">🅿️ Smart Parking Search</div>
    <div class="user-section">
      <div id="userGreeting" class="user-greeting">Loading...</div>
      <button id="logoutBtn" class="logout-btn" style="display: none;">Logout</button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Main Content -->
    <div class="main-content">
      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button class="tab-button active" data-tab="parking">
          🅿️ Find Parking Spots
        </button>
        <button class="tab-button" data-tab="statistics">
          📊 Statistics
        </button>
        <button class="tab-button" data-tab="eco">
          🌱 Eco Planning
        </button>
      </div>

      <!-- Tab Content: Find Parking Spots -->
      <div class="tab-content active" id="parking-tab">
        <h3>🅿️ Find Parking Spots</h3>

        <!-- Search Section -->
        <div class="search-section">
          <h4>Search for Parking</h4>
          <div class="search-input-group">
            <input type="text" id="parkingLocationInput" placeholder="Enter location or address" />
            <select id="parkingTypeSelect">
              <option value="all">All Types</option>
              <option value="street">Street Parking</option>
              <option value="garage">Parking Garage</option>
              <option value="lot">Parking Lot</option>
              <option value="private">Private Parking</option>
            </select>
            <button id="searchParkingBtn">Search Parking</button>
          </div>

          <div class="parking-filters">
            <label>Max Distance:
              <select id="maxDistanceSelect">
                <option value="0.5">0.5 km</option>
                <option value="1">1 km</option>
                <option value="2" selected>2 km</option>
                <option value="5">5 km</option>
                <option value="10">10 km</option>
                <option value="20">20 km (All Melbourne)</option>
              </select>
            </label>

            <label>Price Range:
              <select id="priceRangeSelect">
                <option value="all">Any Price</option>
                <option value="free">Free</option>
                <option value="low">$0-$5/hour</option>
                <option value="medium">$5-$15/hour</option>
                <option value="high">$15+/hour</option>
              </select>
            </label>

            <label>Availability:
              <select id="availabilitySelect">
                <option value="all">All Spots</option>
                <option value="available">🟢 Available Only</option>
                <option value="occupied">🔴 Occupied Only</option>
                <option value="reserved">🟡 Reserved Only</option>
              </select>
            </label>
          </div>

          <div id="parkingSearchStatus" class="info">Ready to search for parking spots across all Melbourne areas</div>

          <!-- Google Map for Parking Search -->
          <div id="parkingMap" class="map-container"></div>
        </div>

        <!-- Parking Results Section -->
        <div id="parkingResultsSection" class="results-section" style="display: none;">
          <h4>Available Parking Spots</h4>
          <div id="parkingResultsCount" class="results-count"></div>
          <div id="parkingResultsGrid" class="parking-results-grid"></div>
        </div>
      </div>

      <!-- Tab Content: Statistics -->
      <div class="tab-content" id="statistics-tab">
        <h3>📊 Melbourne Traffic & Population Statistics</h3>

        <!-- Statistics Controls Section -->
        <div class="search-section">
          <h4>Interactive Analysis Controls</h4>
          <p style="color: #6b7280; margin-bottom: 1.5rem;">Pick a region and year, enter your household vehicles. See where your household sits in the distribution and what it means for congestion.</p>

          <div class="parking-filters">
            <label>Region:
              <select id="stats-region">
                <option>City of Melbourne</option>
                <option>Suburb Melbourne</option>
                <option>Greater Melbourne (All)</option>
              </select>
            </label>

            <label>Year:
              <select id="stats-year">
                <option value="2001">2001</option>
                <option value="2006">2006</option>
                <option value="2011">2011</option>
                <option value="2016">2016</option>
                <option value="2021" selected>2021</option>
              </select>
            </label>

            <label>Vehicles in household:
              <select id="stats-hhcars">
                <option value="0">0</option>
                <option value="1" selected>1</option>
                <option value="2">2</option>
                <option value="3">3+</option>
              </select>
            </label>
          </div>

        </div>

        <!-- KPI Display Section -->
        <div class="search-section">
          <h4>Key Metrics</h4>
          <div class="parking-results-grid">
            <div class="parking-spot">
              <h5>📈 Population</h5>
              <div class="parking-info">
                <span>Current Population</span>
                <span id="stats-pop" style="font-size: 1.2rem; font-weight: bold;">-</span>
              </div>
              <p class="muted-note">Higher population with limited road space increases congestion pressure.</p>
            </div>

            <div class="parking-spot">
              <h5>🚗 Vehicle Density</h5>
              <div class="parking-info">
                <span>Vehicles per 1,000 people</span>
                <span id="stats-vp1000" style="font-size: 1.2rem; font-weight: bold;">-</span>
              </div>
              <p class="muted-note">More cars per 1,000 people means higher road use and potential traffic delays.</p>
            </div>

            <div class="parking-spot">
              <h5>🏠 Your Household</h5>
              
              <div class="parking-info">
                <span>Your percentile</span>
                <span id="stats-percentile" style="font-size: 1.2rem; font-weight: bold;">-</span>
              </div>
              <p class="muted-note">Percentile shows the share of households with <em>equal or fewer</em> cars than yours.</p>
            </div>
          </div>
        </div>

        <!-- Charts Section -->
        <div class="search-section">
          <h4>Visual Analysis</h4>
          <div id="stats-insights" class="insight-box">
            In {region}, the population grew by {X%} from {firstYear} to {lastYear}, while household vehicle ownership grew by {Y%}. This indicates that {summary}.
          </div>
          <div class="stats-charts-grid">
            <div id="stats-chart1" class="map-container" style="height: 400px; background: white;"></div>
            <div id="stats-chart2" class="map-container" style="height: 400px; background: white;"></div>
          </div>
        </div>

        <!-- Data Sources -->
        <div class="search-section">
          <h4>📚 Data Sources</h4>
          <div class="info">
            <ul style="margin-left: 1.5rem; line-height: 1.8;">
              <li>Australian Bureau of Statistics (ABS) — Regional population 2021:
                <a href="https://www.abs.gov.au/statistics/people/population/regional-population/2021/32180DS0001_2001-21.xlsx" target="_blank" style="color: #667eea;">ABS 2001–21 dataset</a>
              </li>
              <li>City of Melbourne — Number of cars per household:
                <a href="https://profile.id.com.au/melbourne/car-ownership?EndYear=2011&DataType=EN" target="_blank" style="color: #667eea;">profile.id: Car ownership</a>
              </li>
            </ul>
           
          </div>
        </div>
      </div>



      <!-- Tab Content: Eco Planning -->
      <div class="tab-content" id="eco-tab">
        <h3>🌱 Eco-Friendly Planning</h3>

        <!-- Carbon Footprint Calculator Section -->
        <div class="search-section">
          <h4>🌍 Carbon Footprint Calculator</h4>
          <div class="search-input-group">
            <input type="text" id="ecoTripOrigin" placeholder="From (your location)" />
            <input type="text" id="ecoTripDestination" placeholder="To (destination)" />
            <button id="calculateEcoBtn">Calculate Impact</button>
          </div>

          <div class="parking-filters">
            <label>Transport Mode:
              <select id="transportModeSelect">
                <option value="car">🚗 Private Car</option>
                <option value="public">🚊 Public Transport</option>
                <option value="bike">🚴 Cycling</option>
                <option value="walk">🚶 Walking</option>
                <option value="carpool">👥 Carpool (2+ people)</option>
              </select>
            </label>

            <label>Car Type (if applicable):
              <select id="carTypeSelect">
                <option value="petrol">⛽ Petrol Car</option>
                <option value="hybrid">🔋 Hybrid</option>
                <option value="electric">⚡ Electric</option>
                <option value="diesel">🛢️ Diesel</option>
              </select>
            </label>

            <label>Trip Frequency:
              <select id="tripFrequencySelect">
                <option value="daily">📅 Daily Commute</option>
                <option value="weekly">📅 Weekly</option>
                <option value="monthly">📅 Monthly</option>
                <option value="once">📅 One-time Trip</option>
              </select>
            </label>
          </div>

          <div id="ecoCalculationStatus" class="info">Enter your trip details to calculate environmental impact</div>

          <!-- Results Display -->
          <div id="ecoResultsSection" class="results-section" style="display: none;">
            <h4>🌱 Environmental Impact Results</h4>
            <div id="ecoComparisonGrid" class="parking-results-grid"></div>
          </div>
        </div>

        <!-- Green Parking Recommendations Section -->
        <div class="search-section">
          <h4>🅿️ Green Parking Recommendations</h4>
          <div class="search-input-group">
            <input type="text" id="greenParkingLocation" placeholder="Search location for eco-friendly parking" />
            <select id="greenFilterSelect">
              <option value="all">🌿 All Green Options</option>
              <option value="publictransport">🚊 Near Public Transport</option>
              <option value="evcharging">⚡ EV Charging Available</option>
              <option value="bikeparking">🚴 Bike Parking Nearby</option>
              <option value="lowcongestion">🚗 Low Congestion Areas</option>
            </select>
            <button id="searchGreenParkingBtn">Find Green Parking</button>
          </div>

          <div id="greenParkingStatus" class="info">Find parking options that support sustainable transportation</div>

          <!-- Green Parking Map -->
          <div id="greenParkingMap" class="map-container"></div>

          <!-- Green Parking Results -->
          <div id="greenParkingResultsSection" class="results-section" style="display: none;">
            <h4>🌱 Eco-Friendly Parking Options</h4>
            <div id="greenParkingResultsCount" class="results-count"></div>
            <div id="greenParkingResultsGrid" class="parking-results-grid"></div>
          </div>
        </div>

        <!-- Sustainability Tips Section -->
        <div class="search-section">
          <h4>💡 Sustainability Tips</h4>
          <div class="parking-results-grid">
            <div class="parking-spot">
              <h5>🚊 Park & Ride</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Park at train stations and use public transport for CBD access</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>Up to 80% reduction in emissions</span>
              </div>
              <div class="eco-badge">🌱 Highly Recommended</div>
            </div>

            <div class="parking-spot">
              <h5>👥 Carpooling</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Share rides with colleagues or use carpooling apps</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>50% reduction per person with 2 people</span>
              </div>
              <div class="eco-badge">🌱 Social Impact</div>
            </div>

            <div class="parking-spot">
              <h5>⚡ Electric Vehicles</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Switch to electric or hybrid vehicles for zero/low emissions</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>Up to 100% reduction (depending on energy source)</span>
              </div>
              <div class="ev-badge">⚡ Future Ready</div>
            </div>

            <div class="parking-spot">
              <h5>🚴 Active Transport</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Cycle or walk for short distances, use bike sharing</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>100% emission-free + health benefits</span>
              </div>
              <div class="eco-badge">💪 Health Bonus</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
<!-- Google Maps API -->
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwXzBClakuchQF0zxKk0UBkPhLX--d7tg&libraries=places&callback=initMaps"></script>

<script>
 // Tab functionality
 function initTabs() {
   const tabButtons = document.querySelectorAll('.tab-button');
   const tabContents = document.querySelectorAll('.tab-content');

   tabButtons.forEach(button => {
     button.addEventListener('click', () => {
       const targetTab = button.getAttribute('data-tab');

       // Remove active class from all buttons and contents
       tabButtons.forEach(btn => btn.classList.remove('active'));
       tabContents.forEach(content => content.classList.remove('active'));

       // Add active class to clicked button and corresponding content
       button.classList.add('active');
       document.getElementById(`${targetTab}-tab`).classList.add('active');
     
    // Initialize statistics when tab is clicked
    if (targetTab === 'statistics') {
        if (!initStatistics._initialized) {
          initStatistics();
          initStatistics._initialized = true;
        } else {
          setTimeout(updateStatistics, 0);
        }
      } 
     
      });
   });
  
 }

 // Statistics Functions
 function initStatistics() {
   debugLog('Initializing statistics module');

   // Initialize year dropdown if not already done
   const yearSelect = document.getElementById('stats-year');
   if (yearSelect) {
     // Clear existing options first
     yearSelect.innerHTML = '';

     // Add year options
     STATS_DATA.years.forEach(year => {
       const option = document.createElement('option');
       option.value = year;
       option.textContent = year;
       yearSelect.appendChild(option);
     });

     // Set default to 2021
     yearSelect.value = 2021;
   }

   // Update statistics on first load
   updateStatistics();
 }

 function numberWithCommas(x) {
   return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
 }

 function carSelectionToCategory(val) {
   val = parseInt(val);
   if (val === 0) return "No motor vehicles";
   if (val === 1) return "1 motor vehicle";
   if (val === 2) return "2 motor vehicles";
   return "3 or more motor vehicles";
 }

 function computePercentile(region, year, hhcars) {
   const cat = carSelectionToCategory(hhcars);
   const order = ["No motor vehicles", "1 motor vehicle", "2 motor vehicles", "3 or more motor vehicles"];
   const counts = order.map(c => STATS_DATA.regions[region].vehicle_categories[c][year]);
   const total = counts.reduce((a, b) => a + b, 0);
   let cum = 0;
   for (let i = 0; i < order.length; i++) {
     cum += counts[i];
     if (order[i] === cat) break;
   }
   return total > 0 ? (cum / total * 100) : 0;
 }

 function drawStatsTrend(region) {
   const years = STATS_DATA.years;
   const pop = years.map(y => STATS_DATA.regions[region].pop_series[y]);
   const vp1000 = years.map(y => STATS_DATA.regions[region].vehicles_per_1000[y]);

   Plotly.newPlot('stats-chart1', [
     {
       x: years,
       y: pop.map(v => v / 1000),
       mode: 'lines+markers',
       name: 'Population (thousands)',
       yaxis: 'y1',
       line: { color: '#667eea', width: 3 },
       marker: { color: '#667eea', size: 8 }
     },
     {
       x: years,
       y: vp1000,
       mode: 'lines+markers',
       name: 'Vehicles per 1,000',
       yaxis: 'y2',
       line: { color: '#764ba2', width: 3 },
       marker: { color: '#764ba2', size: 8 }
     }
   ], {
     title: region + ' — Population & Vehicles/1,000',
     yaxis: { title: 'Population (thousands)' },
     yaxis2: { title: 'Vehicles per 1,000', overlaying: 'y', side: 'right' },
     margin: { t: 40, l: 50, r: 45, b: 40 },
     legend: { orientation: 'h', y: -0.15 },
     paper_bgcolor: 'rgba(0,0,0,0)',
     plot_bgcolor: 'rgba(0,0,0,0)'
   }, { responsive: true });
 }

 function drawStatsCategoryBar(region, year, selectedCars) {
   const cats = STATS_DATA.categories;
   const vals = cats.map(c => STATS_DATA.regions[region].vehicle_categories[c][year]);
   const colors = cats.map(c =>
           c === carSelectionToCategory(selectedCars) ?
                   'rgba(102, 126, 234, 0.9)' :
                   'rgba(200, 200, 200, 0.8)'
   );

   Plotly.newPlot('stats-chart2', [{
     x: cats,
     y: vals,
     type: 'bar',
     name: 'Households',
     marker: { color: colors }
   }], {
     title: region + ' — Household Vehicle Count (' + year + ')',
     yaxis: { title: 'Number of households' },
     margin: { t: 40, l: 50, r: 20, b: 80 },
     paper_bgcolor: 'rgba(0,0,0,0)',
     plot_bgcolor: 'rgba(0,0,0,0)'
   }, { responsive: true });
 }

function updateStatistics() {
  const region = document.getElementById('stats-region').value;
  const year   = document.getElementById('stats-year').value;
  const hhcars = parseInt(document.getElementById('stats-hhcars').value);


  const pop    = STATS_DATA.regions[region].pop_series[year];
  const vp1000 = STATS_DATA.regions[region].vehicles_per_1000[year];
  const pct    = computePercentile(region, year, hhcars); 


  document.getElementById('stats-pop').textContent    = numberWithCommas(pop);
  document.getElementById('stats-vp1000').textContent = vp1000.toFixed(1);
  document.getElementById('stats-percentile').textContent = pct.toFixed(0) + '%';


  drawStatsTrend(region);                     
  drawStatsCategoryBar(region, year, hhcars); 

  (function renderInsights(){
    const firstYear = STATS_DATA.years[0];
    const pop0 = STATS_DATA.regions[region].pop_series[firstYear];
    const pop1 = STATS_DATA.regions[region].pop_series[year];
    const veh0 = STATS_DATA.regions[region].vehicles_total[firstYear];
    const veh1 = STATS_DATA.regions[region].vehicles_total[year];

    const popChg = pop0 ? ((pop1 - pop0) / pop0 * 100).toFixed(1) : '0.0';
    const vehChg = veh0 ? ((veh1 - veh0) / veh0 * 100).toFixed(1) : '0.0';

    let trendLine = '';
    if (parseFloat(vehChg) - parseFloat(popChg) > 3) {
      trendLine = 'car ownership has outpaced population growth, which may intensify congestion.';
    } else if (parseFloat(popChg) - parseFloat(vehChg) > 3) {
      trendLine = 'population has grown faster than car ownership, which may slightly ease congestion pressure.';
    } else {
      trendLine = 'car ownership and population have grown at a similar rate, maintaining current congestion patterns.';
    }

    let youLine = '';
    if (pct >= 70) {
      youLine = `Your household is at the ${pct.toFixed(0)}th percentile — higher vehicle ownership than most households in ${region}.`;
    } else if (pct <= 30) {
      youLine = `Your household is at the ${pct.toFixed(0)}th percentile — lower vehicle ownership than most households in ${region}.`;
    } else {
      youLine = `Your household sits around the middle (the ${pct.toFixed(0)}th percentile), close to the regional norm.`;
    }

    const el = document.getElementById('stats-insights');
    if (el) {
      el.innerHTML = `
        <strong>Insights:</strong>
        In <em>${region}</em>, population grew by <em>${popChg}%</em> from <em>${firstYear}</em> to <em>${year}</em>,
        while household vehicle ownership grew by <em>${vehChg}%</em>. This suggests that ${trendLine}
        <br/>${youLine}
      `;
    }
  })();
}

 // Google Maps Configuration
 let parkingMap;
 let placesService;
 let parkingAutocomplete;
 let parkingMarkers = [];

 // Melbourne coordinates-broader area to show all suburbs
 const MELBOURNE_CENTER = { lat: -37.8136, lng: 144.9631 };
 const MELBOURNE_BOUNDS = {
   north: -37.4,   // Northern suburbs
   south: -38.2,   // Southern suburbs
   east: 145.5,    // Eastern suburbs
   west: 144.4     // Western suburbs
 };

 // Global variables
 let userTokens = null;
 let isAuthenticated = false;
 let melbourneParkingData = [];
 let greenParkingMap;
 let greenParkingAutocomplete;
 let greenParkingMarkers = [];


 // Statistics Data for Melbourne
 const STATS_DATA = {
   "years": [2001, 2006, 2011, 2016, 2021],
   "regions": {
     "City of Melbourne": {
       "pop_series": {"2001": 431549, "2006": 480345, "2011": 532351, "2016": 633471, "2021": 627671},
       "area_km2": 142.5,
       "vehicle_categories": {
         "No motor vehicles": {"2001": 7752, "2006": 12372, "2011": 17430, "2016": 28140, "2021": 32707},
         "1 motor vehicle": {"2001": 9594, "2006": 13564, "2011": 16862, "2016": 21703, "2021": 29957},
         "2 motor vehicles": {"2001": 3954, "2006": 5112, "2011": 5594, "2016": 6210, "2021": 6940},
         "3 or more motor vehicles": {"2001": 792, "2006": 917, "2011": 1099, "2016": 1238, "2021": 1318}
       },
       "vehicles_total": {"2001": 14340, "2006": 19593, "2011": 23555, "2016": 29151, "2021": 38215},
       "vehicles_per_1000": {"2001": 33.2, "2006": 40.8, "2011": 44.2, "2016": 46.0, "2021": 60.9}
     },
     "Suburb Melbourne": {
       "pop_series": {"2001": 3068700, "2006": 3280415, "2011": 3637015, "2016": 4080916, "2021": 4348486},
       "area_km2": 9850.3,
       "vehicle_categories": {
         "No motor vehicles": {"2001": 111069, "2006": 115704, "2011": 116788, "2016": 113436, "2021": 120368},
         "1 motor vehicle": {"2001": 426329, "2006": 443491, "2011": 489269, "2016": 530464, "2021": 630966},
         "2 motor vehicles": {"2001": 442744, "2006": 476241, "2011": 525263, "2016": 572511, "2021": 645910},
         "3 or more motor vehicles": {"2001": 173821, "2006": 195578, "2011": 228809, "2016": 263828, "2021": 302553}
       },
       "vehicles_total": {"2001": 1042894, "2006": 1115310, "2011": 1243341, "2016": 1366803, "2021": 1579429},
       "vehicles_per_1000": {"2001": 339.8, "2006": 340.0, "2011": 341.9, "2016": 334.9, "2021": 363.2}
     },
     "Greater Melbourne (All)": {
       "pop_series": {"2001": 3500249, "2006": 3760760, "2011": 4169366, "2016": 4714387, "2021": 4976157},
       "area_km2": 9992.8,
       "vehicle_categories": {
         "No motor vehicles": {"2001": 118821, "2006": 128076, "2011": 134218, "2016": 141576, "2021": 153075},
         "1 motor vehicle": {"2001": 435923, "2006": 457055, "2011": 506131, "2016": 552167, "2021": 660923},
         "2 motor vehicles": {"2001": 446698, "2006": 481353, "2011": 530857, "2016": 578721, "2021": 652850},
         "3 or more motor vehicles": {"2001": 174613, "2006": 196495, "2011": 229908, "2016": 265066, "2021": 303871}
       },
       "vehicles_total": {"2001": 1057234, "2006": 1134903, "2011": 1266896, "2016": 1395954, "2021": 1617644},
       "vehicles_per_1000": {"2001": 302.0, "2006": 301.8, "2011": 303.9, "2016": 296.1, "2021": 325.1}
     }
   },
   "categories": ["No motor vehicles", "1 motor vehicle", "2 motor vehicles", "3 or more motor vehicles"]
 };

 // DOM elements
 const userGreeting = document.getElementById('userGreeting');
 const logoutBtn = document.getElementById('logoutBtn');
 const parkingLocationInput = document.getElementById('parkingLocationInput');
 const searchParkingBtn = document.getElementById('searchParkingBtn');
 const parkingSearchStatus = document.getElementById('parkingSearchStatus');
 const parkingResultsSection = document.getElementById('parkingResultsSection');
 const parkingResultsGrid = document.getElementById('parkingResultsGrid');

 // Debug mode
 const DEBUG_MODE = true;

 function debugLog(message, data = null) {
   if (DEBUG_MODE) {
     console.log(`[Smart Parking Search DEBUG] ${message}`, data);
   }
 }

 // Initialize Google Maps
 async function initMaps() {
   debugLog('Initializing Google Maps');

   // Load parking data first
   await loadParkingData();

   // Initialize parking search map - zoom out to show all Melbourne
   parkingMap = new google.maps.Map(document.getElementById('parkingMap'), {
     zoom: 10,  // Zoomed out to show entire Melbourne area
     center: MELBOURNE_CENTER,
     styles: [
       {
         featureType: 'poi',
         elementType: 'labels',
         stylers: [{ visibility: 'off' }]
       }
     ]
   });

   // Initialize green parking map (similar setup)
   greenParkingMap = new google.maps.Map(document.getElementById('greenParkingMap'), {
     zoom: 10,
     center: MELBOURNE_CENTER,
     styles: [
       {
         featureType: 'poi',
         elementType: 'labels',
         stylers: [{ visibility: 'off' }]
       }
     ]
   });

   // Initialize places service
   placesService = new google.maps.places.PlacesService(parkingMap);

   // Setup autocomplete for parking search - expanded bounds for all Melbourne
   parkingAutocomplete = new google.maps.places.Autocomplete(
     parkingLocationInput,
     {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false  // Allow searches outside bounds but prioritize Melbourne
     }
   );

   // Setup autocomplete for eco planning inputs
   const ecoTripOrigin = document.getElementById('ecoTripOrigin');
   const ecoTripDestination = document.getElementById('ecoTripDestination');
   const greenParkingLocation = document.getElementById('greenParkingLocation');

   if (ecoTripOrigin) {
     new google.maps.places.Autocomplete(ecoTripOrigin, {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false
     });
   }

   if (ecoTripDestination) {
     new google.maps.places.Autocomplete(ecoTripDestination, {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false
     });
   }

   if (greenParkingLocation) {
     greenParkingAutocomplete = new google.maps.places.Autocomplete(greenParkingLocation, {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false
     });

     greenParkingAutocomplete.addListener('place_changed', onGreenParkingLocationSelected);
   }

   parkingAutocomplete.addListener('place_changed', onParkingLocationSelected);

   debugLog('Google Maps initialized successfully');

   // Initialize authentication after maps are ready
   initAuth();

   // Load real parking data for Melbourne CBD by default
   setTimeout(() => {
     if (melbourneParkingData.length > 0) {
       loadRealParkingData();
     } else {
       // If data isn't loaded yet, try again
       setTimeout(() => {
         loadRealParkingData();
       }, 2000);
     }
   }, 1000);

   // Also set the input to show Melbourne as default (broader area)
   parkingLocationInput.value = "Melbourne, VIC, Australia";
 }

 // Load parking data from S3 or local CSV file
 async function loadParkingData() {
   debugLog('Starting parking data load process...');

   // S3 URL for the CSV file
   const S3_CSV_URL = 'https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bays.csv';

   // Try S3 first, then local file, then fallback to sample data

   // Method 1: Try loading from S3
   try {
     debugLog('Attempting to load CSV from S3:', S3_CSV_URL);
     const response = await fetch(S3_CSV_URL, {
       method: 'GET',
       mode: 'cors', // Enable CORS
       headers: {
         'Accept': 'text/csv,text/plain,*/*'
       }
     });

     debugLog(`S3 Response status: ${response.status} ${response.statusText}`);
     debugLog(`S3 Response headers:`, Object.fromEntries(response.headers.entries()));

     if (response.ok) {
       const csvContent = await response.text();
       debugLog(`S3 Response content length: ${csvContent ? csvContent.length : 0} characters`);

       if (csvContent && csvContent.length > 100) {
         debugLog(`SUCCESS: CSV loaded from S3! Content length: ${csvContent.length} characters`);
         debugLog('First 200 characters:', csvContent.substring(0, 200));
         await parseCSVContent(csvContent);
         return;
       } else {
         debugLog('S3 response content is empty or too small');
       }
     } else {
       debugLog(`S3 fetch failed with status: ${response.status} - ${response.statusText}`);

       // Try to read the error response
       try {
         const errorText = await response.text();
         debugLog('S3 error response:', errorText);
       } catch (e) {
         debugLog('Could not read S3 error response');
       }
     }
   } catch (error) {
     debugLog('S3 loading error details:', {
       name: error.name,
       message: error.message,
       stack: error.stack
     });

     // Check for specific error types
     if (error.name === 'TypeError' && error.message.includes('CORS')) {
       debugLog('CORS ERROR: S3 bucket needs CORS configuration');
     } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
       debugLog('FETCH ERROR: Network or URL issue');
     }
   }

   // Method 2: Try loading from local file system (for development)
   try {
     if (window.fs && window.fs.readFile) {
       debugLog('Attempting to read local CSV file...');
       const csvContent = await window.fs.readFile('on-street-parking-bays.csv', { encoding: 'utf8' });

       if (csvContent && csvContent.length > 100) {
         debugLog(`SUCCESS: CSV loaded locally! Content length: ${csvContent.length} characters`);
         await parseCSVContent(csvContent);
         return;
       }
     }
   } catch (error) {
     debugLog('Local CSV file loading failed:', error.message);
   }

   // Method 3: Fallback to sample data with instructions
   debugLog('All loading methods failed, using sample data');
   showS3Instructions();
 }

 // Parse CSV content into parking data
 async function parseCSVContent(csvContent) {
   debugLog('Parsing CSV content...');

   try {
     const lines = csvContent.trim().split('\n');
     if (lines.length < 2) {
       debugLog('ERROR: CSV has insufficient lines:', lines.length);
       showS3Instructions();
       return;
     }

     // Parse headers
     const headerLine = lines[0];
     const headers = [];
     let current = '';
     let inQuotes = false;

     for (let i = 0; i < headerLine.length; i++) {
       const char = headerLine[i];
       if (char === '"') {
         inQuotes = !inQuotes;
       } else if (char === ',' && !inQuotes) {
         headers.push(current.trim().replace(/"/g, ''));
         current = '';
       } else {
         current += char;
       }
     }
     headers.push(current.trim().replace(/"/g, ''));

     debugLog('CSV Headers found:', headers);

     // Verify we have the expected columns
     const requiredColumns = ['Latitude', 'Longitude', 'RoadSegmentDescription'];
     const missingColumns = requiredColumns.filter(col => !headers.includes(col));
     if (missingColumns.length > 0) {
       debugLog('ERROR: Missing required columns:', missingColumns);
       showS3Instructions();
       return;
     }

     melbourneParkingData = [];
     let processedRows = 0;
     let validRows = 0;

     // Process each data row with progress logging for large datasets
     const totalLines = lines.length - 1;

     for (let i = 1; i < lines.length; i++) {
       const line = lines[i].trim();
       if (!line) continue;

       processedRows++;

       // Log progress for large datasets
       if (processedRows % 5000 === 0) {
         debugLog(`Processing progress: ${processedRows}/${totalLines} rows (${Math.round(processedRows/totalLines*100)}%)`);
       }

       // Parse CSV line handling quoted values
       const values = [];
       let currentValue = '';
       let inQuotes = false;

       for (let j = 0; j < line.length; j++) {
         const char = line[j];
         if (char === '"') {
           inQuotes = !inQuotes;
         } else if (char === ',' && !inQuotes) {
           values.push(currentValue.trim().replace(/^"|"$/g, ''));
           currentValue = '';
         } else {
           currentValue += char;
         }
       }
       values.push(currentValue.trim().replace(/^"|"$/g, ''));

       // Create parking spot object
       const spot = {};
       headers.forEach((header, index) => {
         let value = values[index] || '';

         if (header === 'RoadSegmentID' && value) {
           spot[header] = parseInt(value);
         } else if (header === 'KerbsideID' && value) {
           spot[header] = value ? parseInt(value) : null;
         } else if ((header === 'Latitude' || header === 'Longitude') && value) {
           spot[header] = parseFloat(value);
         } else {
           spot[header] = value;
         }
       });

       // Validate the row has required data
       if (spot.Latitude && spot.Longitude && spot.RoadSegmentDescription &&
           !isNaN(spot.Latitude) && !isNaN(spot.Longitude) &&
           spot.Latitude >= -39 && spot.Latitude <= -37 &&
           spot.Longitude >= 144 && spot.Longitude <= 146) {
         melbourneParkingData.push(spot);
         validRows++;
       }
     }

     debugLog(`SUCCESS: Processed ${processedRows} rows, found ${validRows} valid parking spots from real Melbourne data`);

     // Sample some locations to verify data coverage
     const sampleSpots = melbourneParkingData.slice(0, 5);
     debugLog('Sample parking locations loaded:');
     sampleSpots.forEach((spot, idx) => {
       debugLog(`  ${idx + 1}. ${spot.RoadSegmentDescription}`);
     });

     // Show success message
     setTimeout(() => {
       parkingSearchStatus.innerHTML = `
         <strong>✅ Real Data Loaded!</strong><br>
         Successfully loaded ${validRows} parking spots from your CSV data via S3
       `;
       parkingSearchStatus.className = 'success';
     }, 500);

   } catch (error) {
     debugLog('Error parsing CSV content:', error);
     showS3Instructions();
   }
 }

 // Show error message if real data cannot be loaded
 function showS3Instructions() {
   debugLog('⚠️  Real CSV data could not be loaded from S3 or local file');

   // Clear any existing data
   melbourneParkingData = [];

   debugLog('No sample data created - app will only work with real CSV data');

   // Show detailed error message with troubleshooting steps
   setTimeout(() => {
     parkingSearchStatus.innerHTML = `
       <strong>❌ Unable to Load Real Parking Data from S3</strong><br><br>

       <strong>Current S3 URL:</strong><br>
       <code>https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bays.csv</code><br><br>

       <strong>Common Issues & Solutions:</strong><br>
       1. <strong>CORS Policy:</strong> S3 bucket needs CORS configuration to allow web access<br>
       2. <strong>Public Access:</strong> Ensure the CSV file has public read permissions<br>
       3. <strong>File Location:</strong> Verify the file was uploaded to the correct path<br>
       4. <strong>File Format:</strong> Ensure it's a valid CSV file<br><br>

       <strong>S3 CORS Configuration Needed:</strong><br>
       <code>
       {<br>
       &nbsp;&nbsp;"AllowedOrigins": ["*"],<br>
       &nbsp;&nbsp;"AllowedMethods": ["GET"],<br>
       &nbsp;&nbsp;"AllowedHeaders": ["*"]<br>
       }
       </code><br><br>

       <strong>Check browser console (F12) for detailed error messages.</strong><br>
       <small>App requires real data - no sample data available.</small>
     `;
     parkingSearchStatus.className = 'error';

     // Hide results section since no data is available
     parkingResultsSection.style.display = 'none';
   }, 1000);
 }

 // Handle parking location selection
 function onParkingLocationSelected() {
   const place = parkingAutocomplete.getPlace();
   if (!place.geometry) {
     debugLog('No geometry found for selected place');
     return;
   }

   debugLog('Location selected:', place.name);
   parkingMap.setCenter(place.geometry.location);
   parkingMap.setZoom(16);

   // Clear previous status and show searching
   parkingSearchStatus.innerText = '🔍 Searching for parking near selected location...';
   parkingSearchStatus.className = 'info';

   // Search for nearby parking automatically
   searchNearbyParking(place.geometry.location);
 }

 // Authentication functions
 async function initAuth() {
   debugLog('Initializing authentication');

   // For demo purposes, simulate authentication
   isAuthenticated = true;
   userTokens = { accessToken: 'demo-token', idToken: 'demo-id-token' };

   const userInfo = { username: 'Demo User', email: 'demo@example.com' };

   userGreeting.innerHTML = `Welcome, <strong>${userInfo.username}</strong>`;
   logoutBtn.style.display = 'inline-block';

   debugLog('Demo authentication successful');
 }

 function logout() {
   location.reload();
 }

 logoutBtn.addEventListener('click', logout);

 // Event listeners
 searchParkingBtn.addEventListener('click', searchParking);

 parkingLocationInput.addEventListener('keypress', function(e) {
   if (e.key === 'Enter') {
     e.preventDefault();
     searchParking();
   }
 });

 document.getElementById('maxDistanceSelect').addEventListener('change', function() {
   const location = parkingLocationInput.value.trim();
   if (location) {
     debugLog('Distance filter changed, re-searching...');
     searchParking();
   }
 });

 document.getElementById('parkingTypeSelect').addEventListener('change', function() {
   if (parkingResultsSection.style.display !== 'none') {
     debugLog('Parking type filter changed, re-filtering results...');
     const location = parkingLocationInput.value.trim();
     if (location) {
       searchParking();
     }
   }
 });

 document.getElementById('availabilitySelect').addEventListener('change', function() {
   if (parkingResultsSection.style.display !== 'none') {
     debugLog('Availability filter changed, re-filtering results...');
     const location = parkingLocationInput.value.trim();
     if (location) {
       searchParking();
     }
   }
 });

 // Eco planning event listeners
 setTimeout(() => {
   const calculateEcoBtn = document.getElementById('calculateEcoBtn');
   const searchGreenParkingBtn = document.getElementById('searchGreenParkingBtn');

   if (calculateEcoBtn) {
     calculateEcoBtn.addEventListener('click', calculateCarbonFootprint);
   }

   if (searchGreenParkingBtn) {
     searchGreenParkingBtn.addEventListener('click', searchGreenParking);
   }
 }, 1000);

 // Statistics event listeners
 setTimeout(() => {
   const statsRegion = document.getElementById('stats-region');
  const statsYear = document.getElementById('stats-year');
  const statsHhcars = document.getElementById('stats-hhcars');

  if (statsRegion) statsRegion.addEventListener('change', updateStatistics);
  if (statsYear)   statsYear.addEventListener('change', updateStatistics);
  if (statsHhcars) statsHhcars.addEventListener('change', updateStatistics);
}, 1000);

 function searchParking() {
   const location = parkingLocationInput.value.trim();

   if (!location) {
     parkingSearchStatus.innerText = '❌ Please enter a location.';
     parkingSearchStatus.className = 'error';
     return;
   }

   parkingSearchStatus.innerText = '🔍 Searching for parking spots...';
   parkingSearchStatus.className = 'info';
   searchParkingBtn.disabled = true;

   // Geocode the location first
   const geocoder = new google.maps.Geocoder();
   geocoder.geocode({ address: location }, (results, status) => {
     if (status === 'OK') {
       const searchLocation = results[0].geometry.location;
       parkingMap.setCenter(searchLocation);
       parkingMap.setZoom(16);

       searchNearbyParking(searchLocation);
     } else {
       parkingSearchStatus.innerText = '❌ Location not found.';
       parkingSearchStatus.className = 'error';
       searchParkingBtn.disabled = false;
     }
   });
 }

 // Find nearby parking spots from CSV data
 function findNearbyParkingSpots(centerLat, centerLng, radiusKm = 1) {
   if (!melbourneParkingData || melbourneParkingData.length === 0) {
     debugLog('No parking data available');
     return [];
   }

   const spots = melbourneParkingData.filter(spot => {
     if (!spot.Latitude || !spot.Longitude) return false;

     // Calculate distance using Haversine formula for better accuracy
     const R = 6371; // Earth's radius in kilometers
     const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
     const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
     const a =
       Math.sin(dLat/2) * Math.sin(dLat/2) +
       Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) *
       Math.sin(dLon/2) * Math.sin(dLon/2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
     const distance = R * c; // Distance in km

     return distance <= radiusKm;
   });

   // Sort by distance and return top results
   return spots.map(spot => {
     const R = 6371;
     const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
     const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
     const a =
       Math.sin(dLat/2) * Math.sin(dLat/2) +
       Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) *
       Math.sin(dLon/2) * Math.sin(dLon/2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
     const distance = R * c * 1000; // Distance in meters

     return {
       ...spot,
       distance: Math.round(distance)
     };
   }).sort((a, b) => a.distance - b.distance);
 }

 function searchNearbyParking(location) {
   debugLog('Searching for parking near location:', location.toString());

   // Clear existing markers and results
   parkingMarkers.forEach(marker => marker.setMap(null));
   parkingMarkers = [];
   parkingResultsSection.style.display = 'none';

   const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);

   // Update status
   parkingSearchStatus.innerText = '🔍 Finding parking spots nearby...';
   parkingSearchStatus.className = 'info';

   // Use CSV data to find nearby parking spots
   const nearbySpots = findNearbyParkingSpots(location.lat(), location.lng(), maxDistance);

   if (nearbySpots && nearbySpots.length > 0) {
     // Add random status to each spot for filtering
     const spotsWithStatus = nearbySpots.map(spot => ({
       ...spot,
       status: ['free', 'occupied', 'reserved'][Math.floor(Math.random() * 3)]
     }));

     // Filter based on parking type if needed
     const parkingType = document.getElementById('parkingTypeSelect').value;
     let filteredSpots = spotsWithStatus;

     if (parkingType !== 'all') {
       filteredSpots = spotsWithStatus.filter(spot => {
         const desc = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';
         switch (parkingType) {
           case 'street':
             return desc.includes('street') || desc.includes('road') || desc.includes('avenue');
           case 'garage':
             return desc.includes('garage') || desc.includes('building') || desc.includes('car park');
           case 'lot':
             return desc.includes('lot') || desc.includes('park') && !desc.includes('national');
           case 'private':
             return desc.includes('private') || desc.includes('secure');
           default:
             return true;
         }
       });
     }

     // Filter based on availability
     const availabilityFilter = document.getElementById('availabilitySelect').value;
     if (availabilityFilter !== 'all') {
       const statusMap = {
         'available': 'free',
         'occupied': 'occupied',
         'reserved': 'reserved'
       };
       filteredSpots = filteredSpots.filter(spot => spot.status === statusMap[availabilityFilter]);
     }

     // Limit to top 20 results for better performance
     const topResults = filteredSpots.slice(0, 20);

     displayCSVParkingResults(topResults, location);

     // Add markers ONLY for the filtered results (same availability filter applied)
     const markerResults = filteredSpots.slice(0, 100);
     addAllParkingMarkers(markerResults);

     const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
     parkingSearchStatus.innerText = `✅ Found ${topResults.length}${availabilityText} parking spots nearby (${markerResults.length} shown on map)`;
     parkingSearchStatus.className = 'success';
     parkingResultsSection.style.display = 'block';
   } else {
     const availabilityFilter = document.getElementById('availabilitySelect').value;
     const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
     parkingSearchStatus.innerText = `❌ No${availabilityText} parking spots found in this area. Try adjusting your filters.`;
     parkingSearchStatus.className = 'error';
   }

   // Re-enable search button
   searchParkingBtn.disabled = false;
 }

 function displayCSVParkingResults(spots, searchLocation) {
   // Update results count
   const availabilityFilter = document.getElementById('availabilitySelect').value;
   const filterText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
   document.getElementById('parkingResultsCount').innerText =
     `Found ${spots.length}${filterText} real parking spots from Melbourne data`;

   // Create parking spot cards
   let resultsHTML = '';
   spots.forEach((spot, index) => {
     // Extract street name for cleaner display
     const streetName = spot.RoadSegmentDescription ?
       spot.RoadSegmentDescription.split(' between')[0] : 'Parking Spot';

     // Determine if updated recently (within last year)
     const lastUpdated = new Date(spot.LastUpdated);
     const isRecent = lastUpdated > new Date('2023-01-01');

     // Use the status from the spot (added during search)
     const randomStatus = spot.status || 'free';

     // Status display text and styling
     const statusConfig = {
       free: { text: 'Available', class: 'status-free', emoji: '🟢' },
       occupied: { text: 'Occupied', class: 'status-occupied', emoji: '🔴' },
       reserved: { text: 'Reserved', class: 'status-reserved', emoji: '🟡' }
     };

     const status = statusConfig[randomStatus];

     resultsHTML += `
       <div class="parking-spot">
         <h5>
           🅿️ ${streetName}
           <span class="status-indicator ${status.class}"></span>
         </h5>
         <div class="parking-info">
           <span>Status</span>
           <span style="background: ${randomStatus === 'free' ? 'rgba(16, 185, 129, 0.1); color: #059669' : randomStatus === 'occupied' ? 'rgba(239, 68, 68, 0.1); color: #dc2626' : 'rgba(245, 158, 11, 0.1); color: #d97706'}">${status.emoji} ${status.text}</span>
         </div>
         <div class="parking-info">
           <span>Location</span>
           <span>${spot.RoadSegmentDescription.length > 30 ? spot.RoadSegmentDescription.substring(0, 30) + '...' : spot.RoadSegmentDescription}</span>
         </div>
         <div class="parking-info">
           <span>Distance</span>
           <span>📍 ${spot.distance}m away</span>
         </div>
         <div class="parking-info">
           <span>Segment ID</span>
           <span>#${spot.RoadSegmentID}</span>
         </div>
         <div class="parking-info">
           <span>Last Updated</span>
           <span>🕒 ${spot.LastUpdated}</span>
         </div>
         ${isRecent ? '<div class="eco-badge">✅ Recently Updated</div>' : ''}
         ${spot.KerbsideID ? '<div class="ev-badge">🏷️ Tracked Spot</div>' : ''}
         <div class="parking-actions">
           <button class="navigate-btn" onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${streetName.replace(/'/g, "\\'")}')">
             🧭 Navigate
           </button>
         </div>
       </div>
     `;
   });

   parkingResultsGrid.innerHTML = resultsHTML;
 }

 // Load real parking data for Melbourne (ALL areas) - ONLY real data, no samples
 function loadRealParkingData() {
   debugLog('loadRealParkingData called');
   parkingSearchStatus.innerText = '🔍 Loading Melbourne parking spots from real data...';
   parkingSearchStatus.className = 'info';

   // Clear existing markers
   parkingMarkers.forEach(marker => marker.setMap(null));
   parkingMarkers = [];

   // Check if we have real parking data loaded
   if (!melbourneParkingData || melbourneParkingData.length === 0) {
     debugLog('ERROR: No real parking data available');
     parkingSearchStatus.innerText = '❌ No real parking data loaded. Check S3 configuration.';
     parkingSearchStatus.className = 'error';
     parkingResultsSection.style.display = 'none';
     return;
   }

   debugLog(`Processing ${melbourneParkingData.length} real parking data points from entire Melbourne`);

   // Get current distance filter
   const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);

   // Analyze the geographic distribution of real parking data within distance
   const allSpots = melbourneParkingData.map(spot => {
     const distance = Math.round(
       Math.sqrt(
         Math.pow((spot.Latitude - MELBOURNE_CENTER.lat) * 111000, 2) +
         Math.pow((spot.Longitude - MELBOURNE_CENTER.lng) * 111000, 2)
       )
     );
     return { ...spot, distance };
   }).filter(spot => spot.distance <= maxDistance * 1000); // Filter by distance in meters

   // Add random status to spots
   const spotsWithStatus = allSpots.map(spot => ({
     ...spot,
     status: ['free', 'occupied', 'reserved'][Math.floor(Math.random() * 3)]
   }));

   // Apply availability filter
   const availabilityFilter = document.getElementById('availabilitySelect').value;
   let filteredSpots = spotsWithStatus;
   if (availabilityFilter !== 'all') {
     const statusMap = {
       'available': 'free',
       'occupied': 'occupied',
       'reserved': 'reserved'
     };
     filteredSpots = spotsWithStatus.filter(spot => spot.status === statusMap[availabilityFilter]);
   }

   // Group spots by distance to see real distribution
   const spotsByDistance = {
     cbd: filteredSpots.filter(s => s.distance <= 2000),      // Within 2km of center
     inner: filteredSpots.filter(s => s.distance > 2000 && s.distance <= 10000),  // 2-10km
     outer: filteredSpots.filter(s => s.distance > 10000)     // Beyond 10km
   };

   debugLog(`Filtered parking distribution (${maxDistance}km): CBD (${spotsByDistance.cbd.length}), Inner (${spotsByDistance.inner.length}), Outer (${spotsByDistance.outer.length})`);

   // Sample spots from different areas for display (but all from real data)
   const displaySpots = [];

   // Add CBD spots
   displaySpots.push(...spotsByDistance.cbd.slice(0, 40));

   // Add inner Melbourne spots
   displaySpots.push(...spotsByDistance.inner.slice(0, 40));

   // Add outer Melbourne spots
   displaySpots.push(...spotsByDistance.outer.slice(0, 20));

   // Sort by distance for results display
   const sortedSpots = displaySpots.sort((a, b) => a.distance - b.distance);

   debugLog(`Selected ${sortedSpots.length} real parking spots for display within ${maxDistance}km`);

   if (sortedSpots && sortedSpots.length > 0) {
     displayCSVParkingResults(sortedSpots, { lat: () => MELBOURNE_CENTER.lat, lng: () => MELBOURNE_CENTER.lng });

     const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
     parkingSearchStatus.innerText = `✅ Loaded ${filteredSpots.length}${availabilityText} REAL Melbourne parking spots within ${maxDistance}km (${spotsByDistance.cbd.length} CBD, ${spotsByDistance.inner.length} inner, ${spotsByDistance.outer.length} outer suburbs)`;
     parkingSearchStatus.className = 'success';
     parkingResultsSection.style.display = 'block';

     // Add real parking spots as markers, sampled for performance and filtered by distance
     const allMarkerSpots = [];
     // Sample every 10th spot from CBD
     for (let i = 0; i < spotsByDistance.cbd.length; i += 10) {
       allMarkerSpots.push(spotsByDistance.cbd[i]);
     }
     // Sample every 20th spot from inner
     for (let i = 0; i < spotsByDistance.inner.length; i += 20) {
       allMarkerSpots.push(spotsByDistance.inner[i]);
     }
     // Sample every 50th spot from outer
     for (let i = 0; i < spotsByDistance.outer.length; i += 50) {
       allMarkerSpots.push(spotsByDistance.outer[i]);
     }

     addAllParkingMarkers(allMarkerSpots);
     debugLog(`Added ${allMarkerSpots.length} markers from real data within ${maxDistance}km range`);

     // Adjust map zoom based on distance filter
     let zoomLevel = 10;
     if (maxDistance <= 1) zoomLevel = 15;
     else if (maxDistance <= 2) zoomLevel = 14;
     else if (maxDistance <= 5) zoomLevel = 12;
     else if (maxDistance <= 10) zoomLevel = 11;

     parkingMap.setZoom(zoomLevel);

   } else {
     debugLog('No real parking spots available for display within distance');
     const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
     parkingSearchStatus.innerText = `❌ No${availabilityText} real parking data available within ${maxDistance}km.`;
     parkingSearchStatus.className = 'error';
     parkingResultsSection.style.display = 'none';
   }
 }

 // Add function to display many markers on map
 function addAllParkingMarkers(spots) {
   spots.forEach((spot, index) => {
     // Use the status from the spot (added during search)
     const randomStatus = spot.status || 'free';

     // Marker colors based on status
     const markerColors = {
       free: '#10b981',      // Green
       occupied: '#ef4444',   // Red
       reserved: '#f59e0b'    // Amber/Orange
     };

     const markerColor = markerColors[randomStatus];

     const marker = new google.maps.Marker({
       position: { lat: spot.Latitude, lng: spot.Longitude },
       map: parkingMap,
       title: `${spot.RoadSegmentDescription} (${spot.distance}m away)`,
       icon: {
         url: 'data:image/svg+xml;base64,' + btoa(`
           <svg width="24" height="24" xmlns="http://www.w3.org/2000/svg">
             <circle cx="12" cy="12" r="10" fill="${markerColor}" stroke="#ffffff" stroke-width="2"/>
             <circle cx="12" cy="12" r="6" fill="${markerColor}" opacity="0.8"/>
             <text x="12" y="16" text-anchor="middle" fill="white" font-size="10" font-family="Arial" font-weight="bold">P</text>
           </svg>
         `),
         scaledSize: new google.maps.Size(24, 24),
         anchor: new google.maps.Point(12, 12)
       }
     });

     // Status display configuration
     const statusConfig = {
       free: { text: 'Available', emoji: '🟢', color: '#10b981' },
       occupied: { text: 'Occupied', emoji: '🔴', color: '#ef4444' },
       reserved: { text: 'Reserved', emoji: '🟡', color: '#f59e0b' }
     };

     const status = statusConfig[randomStatus];

     // Enhanced info window with status
     const infoWindow = new google.maps.InfoWindow({
       content: `
         <div style="padding: 12px; max-width: 280px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
           <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
             <h5 style="margin: 0; color: #1a202c; font-size: 1.1rem; font-weight: 700;">🅿️ ${spot.RoadSegmentDescription.length > 35 ? spot.RoadSegmentDescription.substring(0, 35) + '...' : spot.RoadSegmentDescription}</h5>
           </div>

           <div style="background: ${status.color}15; border-left: 4px solid ${status.color}; padding: 8px 12px; border-radius: 8px; margin-bottom: 12px;">
             <div style="display: flex; align-items: center; gap: 6px;">
               <span style="font-size: 14px;">${status.emoji}</span>
               <strong style="color: ${status.color}; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">${status.text}</strong>
             </div>
           </div>

           <div style="display: grid; gap: 6px; font-size: 0.85rem;">
             <div style="display: flex; justify-content: space-between;">
               <span style="color: #6b7280; font-weight: 600;">Distance:</span>
               <span style="font-weight: 700; color: #1a202c;">📍 ${spot.distance}m</span>
             </div>
             <div style="display: flex; justify-content: space-between;">
               <span style="color: #6b7280; font-weight: 600;">Segment ID:</span>
               <span style="font-weight: 700; color: #1a202c;">#${spot.RoadSegmentID}</span>
             </div>
             <div style="display: flex; justify-content: space-between;">
               <span style="color: #6b7280; font-weight: 600;">Updated:</span>
               <span style="font-weight: 700; color: #1a202c;">🕒 ${spot.LastUpdated}</span>
             </div>
           </div>
         </div>
       `
     });

     marker.addListener('click', () => {
       // Close other info windows
       parkingMarkers.forEach(m => {
         if (m.infoWindow) {
           m.infoWindow.close();
         }
       });
       infoWindow.open(parkingMap, marker);
     });

     marker.infoWindow = infoWindow;
     parkingMarkers.push(marker);
   });

   debugLog(`Added ${spots.length} parking markers to map with status colors`);
 }

 // Navigation function to open Google Maps with directions
 function navigateToParking(lat, lng, name) {
   debugLog('Opening navigation to parking spot', { lat, lng, name });

   // Create Google Maps URL for navigation
   const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_name=${encodeURIComponent(name)}`;

   // Open in new tab/window
   window.open(googleMapsUrl, '_blank');
 }

 // ECO PLANNING FUNCTIONS
  // Calculate carbon footprint
  function calculateCarbonFootprint() {
    const origin = document.getElementById('ecoTripOrigin').value.trim();
    const destination = document.getElementById('ecoTripDestination').value.trim();
    const transportMode = document.getElementById('transportModeSelect').value;
    const carType = document.getElementById('carTypeSelect').value;
    const frequency = document.getElementById('tripFrequencySelect').value;
    const statusEl = document.getElementById('ecoCalculationStatus');
    const resultsSection = document.getElementById('ecoResultsSection');
    const resultsGrid = document.getElementById('ecoComparisonGrid');

    if (!origin || !destination) {
      statusEl.innerText = '❌ Please enter both origin and destination.';
      statusEl.className = 'error';
      return;
    }

    statusEl.innerText = '🔍 Calculating environmental impact...';
    statusEl.className = 'info';

    // First try to geocode both locations to get coordinates
    const geocoder = new google.maps.Geocoder();

    Promise.all([
      new Promise((resolve, reject) => {
        geocoder.geocode({ address: origin }, (results, status) => {
          if (status === 'OK') resolve(results[0]);
          else reject(new Error('Origin not found'));
        });
      }),
      new Promise((resolve, reject) => {
        geocoder.geocode({ address: destination }, (results, status) => {
          if (status === 'OK') resolve(results[0]);
          else reject(new Error('Destination not found'));
        });
      })
    ]).then(([originResult, destResult]) => {
      debugLog('Geocoding successful for both locations');

      // Calculate distance using haversine formula as fallback
      const originLatLng = originResult.geometry.location;
      const destLatLng = destResult.geometry.location;

      const distance = calculateDistanceKm(
        originLatLng.lat(),
        originLatLng.lng(),
        destLatLng.lat(),
        destLatLng.lng()
      );

      debugLog(`Calculated distance: ${distance}km`);

      // Estimate duration based on distance (rough estimate)
      const estimatedDuration = Math.round(distance * 1.5); // Assume ~40km/h average in Melbourne
      const durationText = `${estimatedDuration} mins (estimated)`;

      // Use Google Maps Distance Matrix for more accurate data, with fallback
      const service = new google.maps.DistanceMatrixService();
      service.getDistanceMatrix({
        origins: [originResult.formatted_address],
        destinations: [destResult.formatted_address],
        travelMode: google.maps.TravelMode.DRIVING,
        unitSystem: google.maps.UnitSystem.METRIC,
        avoidHighways: false,
        avoidTolls: false
      }, function(response, status) {
        let finalDistance = distance;
        let finalDuration = durationText;

        if (status === 'OK' && response.rows[0].elements[0].status === 'OK') {
          // Use Google Maps data if available
          finalDistance = response.rows[0].elements[0].distance.value / 1000;
          finalDuration = response.rows[0].elements[0].duration.text;
          debugLog('Using Google Maps distance data');
        } else {
          debugLog('Using fallback distance calculation');
        }

        // Calculate emissions for different transport modes
        const emissions = calculateEmissions(finalDistance, transportMode, carType, frequency);
        displayEmissionsResults(emissions, finalDistance, finalDuration, frequency, resultsGrid, statusEl, resultsSection);
      });

    }).catch(error => {
      debugLog('Geocoding error:', error);
      statusEl.innerText = '❌ Could not find one or both locations. Please check your addresses and try again.';
      statusEl.className = 'error';
    });
  }

 // Helper function to calculate distance between two coordinates using Haversine formula
 function calculateDistanceKm(lat1, lng1, lat2, lng2) {
   const R = 6371; // Earth's radius in kilometers
   const dLat = (lat2 - lat1) * Math.PI / 180;
   const dLng = (lng2 - lng1) * Math.PI / 180;
   const a =
     Math.sin(dLat/2) * Math.sin(dLat/2) +
     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
     Math.sin(dLng/2) * Math.sin(dLng/2);
   const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
   const distance = R * c;
   return Math.round(distance * 10) / 10; // Round to 1 decimal place
 }


 // Calculate emissions based on distance and transport mode
 function calculateEmissions(distance, mode, carType, frequency) {
   // CO2 emissions in kg per km (approximate values)
   const emissionFactors = {
     car: {
       petrol: 0.19,      // kg CO2 per km
       diesel: 0.17,
       hybrid: 0.10,
       electric: 0.05     // Depends on grid energy mix
     },
     public: 0.06,        // Average for Melbourne public transport
     bike: 0.0,
     walk: 0.0,
     carpool: 0.095       // Half of petrol car (assuming 2 people)
   };

   // Frequency multipliers (trips per year)
   const frequencyMultipliers = {
     daily: 250,    // Work days per year (5 days × 50 weeks)
     weekly: 52,
     monthly: 12,
     once: 1
   };

   let emissionFactor;
   if (mode === 'car') {
     emissionFactor = emissionFactors.car[carType];
   } else {
     emissionFactor = emissionFactors[mode];
   }

   const singleTripEmissions = distance * emissionFactor * 2; // Round trip
   const annualEmissions = singleTripEmissions * frequencyMultipliers[frequency];

   // Calculate costs (approximate)
   const fuelCostPerKm = 0.12; // AUD per km
   const singleTripCost = mode === 'car' ? (distance * 2 * fuelCostPerKm) :
                         mode === 'public' ? 4.50 : 0; // Average PT fare
   const annualCost = singleTripCost * frequencyMultipliers[frequency];

   return {
     singleTrip: singleTripEmissions,
     annual: annualEmissions,
     singleTripCost,
     annualCost,
     distance,
     mode,
     carType,
     frequency
   };
 }

 // Display emissions calculation results
 function displayEmissionsResults(emissions, distance, duration, frequency, resultsGrid, statusEl, resultsSection) {
   // Generate comparison with other transport modes
   const modes = ['car', 'public', 'carpool', 'bike'];
   const carTypes = ['petrol', 'hybrid', 'electric'];

   let comparisons = [];

   modes.forEach(mode => {
     if (mode === 'car') {
       carTypes.forEach(carType => {
         const comparison = calculateEmissions(distance, mode, carType, frequency);
         comparison.label = `🚗 ${carType.charAt(0).toUpperCase() + carType.slice(1)} Car`;
         comparison.icon = mode === 'car' && carType === 'electric' ? '⚡' : '🚗';
         comparisons.push(comparison);
       });
     } else {
       const comparison = calculateEmissions(distance, mode, 'petrol', frequency);
       const labels = {
         public: '🚊 Public Transport',
         carpool: '👥 Carpool',
         bike: '🚴 Cycling',
         walk: '🚶 Walking'
       };
       comparison.label = labels[mode];
       comparison.icon = mode === 'public' ? '🚊' : mode === 'carpool' ? '👥' : mode === 'bike' ? '🚴' : '🚶';
       comparisons.push(comparison);
     }
   });

   // Sort by annual emissions (lowest first)
   comparisons.sort((a, b) => a.annual - b.annual);

   let resultsHTML = '';

   comparisons.forEach((comp, index) => {
     const isCurrentChoice = comp.mode === emissions.mode &&
                            (comp.mode !== 'car' || comp.carType === emissions.carType);
     const isGreenest = index === 0 && comp.annual > 0;
     const isCarbonNeutral = comp.annual === 0;

     const frequencyText = {
       daily: 'per work day',
       weekly: 'per week',
       monthly: 'per month',
       once: 'one-time'
     };

     resultsHTML += `
       <div class="parking-spot ${isCurrentChoice ? 'current-choice' : ''}" style="${isCurrentChoice ? 'border: 2px solid #667eea;' : ''}">
         <h5>${comp.icon} ${comp.label} ${isCurrentChoice ? '(Your Choice)' : ''}</h5>

         <div class="parking-info">
           <span>Single Trip</span>
           <span>${comp.singleTrip.toFixed(2)} kg CO2</span>
         </div>

         <div class="parking-info">
           <span>Annual Impact</span>
           <span>${comp.annual.toFixed(1)} kg CO2/year</span>
         </div>

         <div class="parking-info">
           <span>Cost ${frequencyText[frequency]}</span>
           <span>$${comp.singleTripCost.toFixed(2)}</span>
         </div>

         <div class="parking-info">
           <span>Annual Cost</span>
           <span>$${comp.annualCost.toFixed(0)}</span>
         </div>

         ${isCarbonNeutral ? '<div class="eco-badge">🌱 Carbon Neutral</div>' : ''}
         ${isGreenest && !isCarbonNeutral ? '<div class="eco-badge">🏆 Lowest Emissions</div>' : ''}
         ${comp.annual > 1000 ? '<div class="ev-badge" style="background: linear-gradient(135deg, #ef4444, #dc2626);">⚠️ High Impact</div>' : ''}
       </div>
     `;
   });

   resultsGrid.innerHTML = resultsHTML;

   const frequencyText = {
     daily: 'daily commute',
     weekly: 'weekly trips',
     monthly: 'monthly trips',
     once: 'one-time trip'
   };

   statusEl.innerHTML = `✅ Environmental impact calculated for ${distance.toFixed(1)}km ${frequencyText[frequency]} (${duration} by car)`;
   statusEl.className = 'success';
   resultsSection.style.display = 'block';
 }

 // Handle green parking location selection
 function onGreenParkingLocationSelected() {
   const place = greenParkingAutocomplete.getPlace();
   if (!place.geometry) {
     debugLog('No geometry found for green parking location');
     return;
   }

   debugLog('Green parking location selected:', place.name);
   greenParkingMap.setCenter(place.geometry.location);
   greenParkingMap.setZoom(16);

   searchGreenParkingNearLocation(place.geometry.location);
 }

 // Search for green parking options
 function searchGreenParking() {
   const location = document.getElementById('greenParkingLocation').value.trim();
   const greenFilter = document.getElementById('greenFilterSelect').value;
   const statusEl = document.getElementById('greenParkingStatus');

   if (!location) {
     statusEl.innerText = '❌ Please enter a location.';
     statusEl.className = 'error';
     return;
   }

   statusEl.innerText = '🔍 Searching for eco-friendly parking options...';
   statusEl.className = 'info';

   // Geocode the location
   const geocoder = new google.maps.Geocoder();
   geocoder.geocode({ address: location }, (results, status) => {
     if (status === 'OK') {
       const searchLocation = results[0].geometry.location;
       greenParkingMap.setCenter(searchLocation);
       greenParkingMap.setZoom(16);

       searchGreenParkingNearLocation(searchLocation, greenFilter);
     } else {
       statusEl.innerText = '❌ Location not found.';
       statusEl.className = 'error';
     }
   });
 }

 // Search for green parking near location
 function searchGreenParkingNearLocation(location, filter = 'all') {
   const statusEl = document.getElementById('greenParkingStatus');
   const resultsSection = document.getElementById('greenParkingResultsSection');
   const resultsGrid = document.getElementById('greenParkingResultsGrid');
   const resultsCount = document.getElementById('greenParkingResultsCount');

   // Clear existing markers
   greenParkingMarkers.forEach(marker => marker.setMap(null));
   greenParkingMarkers = [];

   // Find nearby parking spots from real data
   const nearbySpots = findNearbyParkingSpots(location.lat(), location.lng(), 2); // 2km radius

   if (nearbySpots && nearbySpots.length > 0) {
     // Add green attributes to spots based on filter
     const greenSpots = nearbySpots.map(spot => {
       const greenScore = calculateGreenScore(spot, filter);
       return {
         ...spot,
         greenScore,
         sustainabilityFeatures: getSustainabilityFeatures(spot, filter)
       };
     }).filter(spot => spot.greenScore > 0)
       .sort((a, b) => b.greenScore - a.greenScore)
       .slice(0, 15); // Top 15 green spots

     displayGreenParkingResults(greenSpots, filter, resultsGrid, resultsCount, statusEl, resultsSection);
     addGreenParkingMarkers(greenSpots);
   } else {
     statusEl.innerText = '❌ No eco-friendly parking options found in this area.';
     statusEl.className = 'error';
     resultsSection.style.display = 'none';
   }
 }

 // Calculate green score for parking spots
 function calculateGreenScore(spot, filter) {
   let score = 0;
   const description = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';

   // Base score for all spots
   score += 10;

   // Public transport proximity (simulated)
   if (description.includes('flinders') || description.includes('collins') ||
       description.includes('bourke') || description.includes('station')) {
     score += 30; // Near major transport hubs
   }

   // Low congestion areas
   if (description.includes('lane') || description.includes('side') ||
       !description.includes('street')) {
     score += 20; // Quieter areas
   }

   // EV charging potential (simulated based on location)
   if (description.includes('centre') || description.includes('plaza') ||
       description.includes('complex')) {
     score += 25; // Commercial areas likely to have EV charging
   }

   // Bike parking friendly areas
   if (description.includes('park') || description.includes('garden') ||
       description.includes('square')) {
     score += 15; // Areas with space for bike parking
   }

   // Apply filter-specific scoring
   if (filter === 'publictransport') {
     score = description.includes('flinders') || description.includes('collins') ||
             description.includes('bourke') || description.includes('station') ? score : 0;
   } else if (filter === 'evcharging') {
     score = description.includes('centre') || description.includes('plaza') ||
             description.includes('complex') ? score : 0;
   } else if (filter === 'bikeparking') {
     score = description.includes('park') || description.includes('garden') ||
             description.includes('square') ? score : 0;
   } else if (filter === 'lowcongestion') {
     score = description.includes('lane') || description.includes('side') ||
             !description.includes('street') ? score : 0;
   }

   return score;
 }

 // Get sustainability features for a parking spot
 function getSustainabilityFeatures(spot, filter) {
   const features = [];
   const description = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';

   if (description.includes('flinders') || description.includes('collins') ||
       description.includes('bourke') || description.includes('station')) {
     features.push('🚊 Near Public Transport');
   }

   if (description.includes('centre') || description.includes('plaza') ||
       description.includes('complex')) {
     features.push('⚡ EV Charging Likely');
   }

   if (description.includes('park') || description.includes('garden') ||
       description.includes('square')) {
     features.push('🚴 Bike Parking Available');
   }

   if (description.includes('lane') || description.includes('side') ||
       !description.includes('street')) {
     features.push('🌱 Low Congestion Zone');
   }

   // Add some random green features for demonstration
   if (Math.random() > 0.7) {
     features.push('🌳 Tree-Lined Street');
   }

   if (Math.random() > 0.8) {
     features.push('♻️ Recycling Nearby');
   }

   return features;
 }

 // Display green parking results
 function displayGreenParkingResults(spots, filter, resultsGrid, resultsCount, statusEl, resultsSection) {
   const filterNames = {
     all: '',
     publictransport: 'near public transport',
     evcharging: 'with EV charging',
     bikeparking: 'with bike parking',
     lowcongestion: 'in low congestion areas'
   };

   resultsCount.innerText = `Found ${spots.length} eco-friendly parking spots ${filterNames[filter] || ''}`;

   let resultsHTML = '';
   spots.forEach((spot, index) => {
     const isTopChoice = index < 3;
     const greenScore = Math.round((spot.greenScore / 100) * 100);

     resultsHTML += `
       <div class="parking-spot" style="${isTopChoice ? 'border-left: 4px solid #10b981;' : ''}">
         <h5>
           🅿️ ${spot.RoadSegmentDescription.length > 30 ?
                spot.RoadSegmentDescription.substring(0, 30) + '...' :
                spot.RoadSegmentDescription}
           ${isTopChoice ? '<span style="color: #10b981; font-size: 0.8rem; margin-left: 0.5rem;">⭐ Top Choice</span>' : ''}
         </h5>

         <div class="parking-info">
           <span>Green Score</span>
           <span style="background: linear-gradient(135deg, #10b981, #059669); color: white; border-radius: 6px; padding: 0.2rem 0.6rem; font-weight: bold;">${greenScore}% 🌱</span>
         </div>

         <div class="parking-info">
           <span>Distance</span>
           <span>📍 ${spot.distance}m away</span>
         </div>

         <div class="parking-info">
           <span>Environmental Benefits</span>
           <span style="font-size: 0.85rem;">${spot.sustainabilityFeatures.slice(0, 2).join(', ')}</span>
         </div>

         <div class="parking-info">
           <span>Segment ID</span>
           <span>#${spot.RoadSegmentID}</span>
         </div>

         ${spot.sustainabilityFeatures.map(feature => `<div class="eco-badge" style="margin: 0.2rem 0.2rem 0.2rem 0;">${feature}</div>`).join('')}

         <div class="parking-actions">
           <button class="navigate-btn" onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${spot.RoadSegmentDescription.replace(/'/g, "\\'")}')">
             🧭 Navigate
           </button>
         </div>
       </div>
     `;
   });

   resultsGrid.innerHTML = resultsHTML;
   statusEl.innerText = `✅ Found ${spots.length} eco-friendly parking options with sustainability features`;
   statusEl.className = 'success';
   resultsSection.style.display = 'block';
 }

 // Add green parking markers to map
 function addGreenParkingMarkers(spots) {
   spots.forEach((spot, index) => {
     const isTopChoice = index < 3;
     const markerColor = isTopChoice ? '#10b981' : '#22c55e'; // Different greens for top choices

     const marker = new google.maps.Marker({
       position: { lat: spot.Latitude, lng: spot.Longitude },
       map: greenParkingMap,
       title: `${spot.RoadSegmentDescription} - Green Score: ${Math.round((spot.greenScore / 100) * 100)}%`,
       icon: {
         url: 'data:image/svg+xml;base64,' + btoa(`
           <svg width="28" height="28" xmlns="http://www.w3.org/2000/svg">
             <circle cx="14" cy="14" r="12" fill="${markerColor}" stroke="#ffffff" stroke-width="2"/>
             <circle cx="14" cy="14" r="8" fill="${markerColor}" opacity="0.8"/>
             <text x="14" y="18" text-anchor="middle" fill="white" font-size="10" font-family="Arial" font-weight="bold">🌱</text>
           </svg>
         `),
         scaledSize: new google.maps.Size(28, 28),
         anchor: new google.maps.Point(14, 14)
       }
     });

     const greenScore = Math.round((spot.greenScore / 100) * 100);
     const infoWindow = new google.maps.InfoWindow({
       content: `
         <div style="padding: 12px; max-width: 300px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
           <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
             <h5 style="margin: 0; color: #1a202c; font-size: 1.1rem; font-weight: 700;">🅿️ ${spot.RoadSegmentDescription.length > 35 ? spot.RoadSegmentDescription.substring(0, 35) + '...' : spot.RoadSegmentDescription}</h5>
           </div>

            <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 8px 12px; border-radius: 8px; margin-bottom: 12px; text-align: center;">
              <div style="font-size: 1.1rem; font-weight: bold;">🌱 Green Score: ${greenScore}%</div>
            </div>

            <div style="display: grid; gap: 6px; font-size: 0.85rem; margin-bottom: 10px;">
              <div style="display: flex; justify-content: space-between;">
                <span style="color: #6b7280; font-weight: 600;">Distance:</span>
                <span style="font-weight: 700; color: #1a202c;">📍 ${spot.distance}m</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span style="color: #6b7280; font-weight: 600;">Segment ID:</span>
                <span style="font-weight: 700; color: #1a202c;">#${spot.RoadSegmentID}</span>
              </div>
            </div>

            <div style="font-size: 0.8rem; color: #10b981; font-weight: 600; margin-bottom: 8px;">Sustainability Features:</div>
            <div style="display: flex; flex-wrap: wrap; gap: 4px;">
              ${spot.sustainabilityFeatures.map(feature =>
                `<span style="background: rgba(16, 185, 129, 0.1); color: #059669; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem;">${feature}</span>`
              ).join('')}
            </div>
          </div>
        `
      });

      marker.addListener('click', () => {
        // Close other info windows
        greenParkingMarkers.forEach(m => {
          if (m.infoWindow) {
            m.infoWindow.close();
          }
        });
        infoWindow.open(greenParkingMap, marker);
      });

      marker.infoWindow = infoWindow;
      greenParkingMarkers.push(marker);
    });

    debugLog(`Added ${spots.length} green parking markers to map`);
  }

  // Error handling for Google Maps API
  window.gm_authFailure = function() {
    debugLog('Google Maps API authentication failed');
    document.getElementById('parkingMap').innerHTML =
      '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666;"><p>⚠️ Google Maps API key required. Please add your API key to enable maps.</p></div>';
  };

  // Initialize app when page loads
  document.addEventListener('DOMContentLoaded', function() {
    debugLog('Smart Parking Search app initialized');

    // Initialize tabs
    initTabs();

    // If Google Maps fails to load, show fallback
    setTimeout(() => {
      if (typeof google === 'undefined') {
        debugLog('Google Maps API not loaded, showing fallback');
        document.getElementById('parkingMap').innerHTML =
          '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; flex-direction: column;"><p>🗺️ Parking Map</p><p style="font-size: 0.9rem; margin-top: 0.5rem;">Add your Google Maps API key to enable full functionality</p></div>';

        // Still initialize auth for demo
        initAuth();
      }
    }, 3000);
  });
  </script>
  </body>
  </html>